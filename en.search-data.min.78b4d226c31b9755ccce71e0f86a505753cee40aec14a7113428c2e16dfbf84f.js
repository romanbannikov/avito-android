'use strict';(function(){const indexCfg={cache:true,split:/[^a-zа-яё0-9\w]/gi};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/avito-android/posts/lint-worker-api-workaround/','title':"Android lint and Gradle worker API workaround",'content':"Workaround for Android lint that doesn\u0026rsquo;t use Gradle Worker API Issue #145235363\nProblem We have a lot of modules in the project, and things build in parallel very well. However, there is a contention between Android lint and UI-tests in CI builds. Both tasks are on a final application module.\nWe use workers to parallelize different UI-testing tasks and enable Gradle workers API for available android Gradle plugin tasks.\nAndroid lint does not use Gradle Worker API yet and blocks any of these optimizations on most occasions.\nIt is so, because Gradle holds module (project) lock, and even if your task use workers, it should acquire the lock to start or report finish.\nSo it will parallelize as nice as you might expect only if all tasks running on module use workers, or non-worker task is fast enough to even bother.\nTasks report finish time later than actual: gradle #8630   gantt title Lint blocks instrumentation to start dateFormat YYYY-MM-DD axisFormat %j section project package :package, 1000-01-01, 11d lint :lint, 1000-01-02, 10d instrumentation :after lint package, 10d Solution We ended up with a kinda dirty and in-theory unstable hack, but it works well.\nLet\u0026rsquo;s take a look only on final application module tasks:\n Long tasks supporting workers API (good tasks) must start as soon as all its dependencies ready. It will release a lock right after the start Android lint (bad task) should start right after it, holding a lock until the end Even if good tasks finished before lint we end a whole build in much more optimal time than consequentially  gantt title Lint runs in parallel with instrumentation dateFormat YYYY-MM-DD axisFormat %j section project package :package, 1000-01-01, 3d instrumentation :after package, 11d lint :lint, 1000-01-05, 10d Implementation We have introduced preInstrumentation task for UI-tests, that depends on the same tasks as instrumentation one\u0026rsquo;s, but doing nothing other than mustRunAfter point to lint task, moving it next to UI-tests.\n"});index.add({'id':1,'href':'/avito-android/tags/agp/','title':"agp",'content':""});index.add({'id':2,'href':'/avito-android/posts/','title':"Blog",'content':""});index.add({'id':3,'href':'/avito-android/tags/gradle/','title':"gradle",'content':""});index.add({'id':4,'href':'/avito-android/','title':"Introduction",'content':"Android in Avito Multiple projects live in two repositories:\n Open Source repository (https://github.com/avito-tech/avito-android) - monorepo of all tooling to continuously test and deliver apps to users Internal repository (closed source) - monorepo of all apps and shared libraries  Open Source repository Contacts: Telegram chat (Russian)\nAll source code lives in subprojects/:\n android-test - code that goes in androidTestImplementation configuration and runs on emulators gradle - Gradle plugins and buildscript dependencies common - shared code between android-test and gradle  More details - project structure\nBesides these modules you will find:\n ci/ and /*.sh - we follow IaC principle whenever possible. You can see docker images we use to abstract configuration of apps building and testing, as well as testing github project itself. docs/ - documentation you see right now and code to deploy it automatically.\nHow we document You could see links to \u0026ldquo;internal\u0026rdquo; resources that are not available for non-employees (links.k.avito.ru).\nIt has been done on purpose to have single documentation and show the whole picture.    Closed source internal repository  How to start  "});index.add({'id':5,'href':'/avito-android/tags/lint/','title':"lint",'content':""});index.add({'id':6,'href':'/avito-android/tags/','title':"Tags",'content':""});index.add({'id':7,'href':'/avito-android/docs/analytics/analytics/','title':"Analytics",'content':"Analytics Для сбора данных используем собственные транспорты:\n Clickstream (internal) Statsd  Поверх транспорта есть готовые обертки под конкретные задачи:\n Performance аналитика  "});index.add({'id':8,'href':'/avito-android/docs/checks/androidlint/','title':"Android Lint",'content':"Android Lint https://developer.android.com/studio/write/lint\nВ PR результаты отображаются во вкладках \u0026ldquo;\u0026lt;app name\u0026gt; lint\u0026rdquo;.\nНастройки Помимо стандартных настроек lint у нас есть:\n Проставляем общие lintOptions для всех модулей в рутовом build.gradle Рутовый lint.xml для задания исключений для всех модулей в репозитории Плагин для общего lint отчета по всем модулям: com.avito.android.lint-report  Как подавить ошибку? Используем стандартные возможности lint (Configure lint to suppress warnings):\n Проставить аннотацию @Suppress в коде, если это единичное ложное срабатывание Добавить исключение в lint.xml  Конкретного модуля (android library).\nИспользуем lintOptions.checkDependencies, поэтому может не примениться для приложения, которое подключает модуль. Приложения (android application) Всего репозитория. Отключит проверку во всех модулях.    Custom lint checks All customs android lint checks are in lint-checks (internal) module.\nWriting a custom lint check  Static Analysis with Android Lint by Tor Norbye (mDevCamp 2019) Sample project  "});index.add({'id':9,'href':'/avito-android/docs/ide/templates/','title':"Android Studio templates",'content':"Android Studio templates Запустите install_templates.sh или скопируйте папку вручную из ./templates в $ANDROID_STUDIO_DIR/plugins/android/lib/templates/other\n"});index.add({'id':10,'href':'/avito-android/docs/cd/artifacts/','title':"Artifacts",'content':"Артефакты сборки (internal) Где храним артефакты? Используем несколько хранилищ:\n Artifactory  feature-toggles.json api.json staging apk   QApps Play market/Play console  релизный aab релизный proguard mapping   Teamcity Android PR checks  Вкладка Artifacts у билда Все файлы pull request Живет ~ 1 месяц   Teamcity Android Release  Вкладка Artifacts у билда Все файлы релизной сборки Живет ~ 1 месяц    "});index.add({'id':11,'href':'/avito-android/docs/assemble/buildtypes/','title':"Build Types",'content':"Типы сборок Различаются по предназначению:\n debug - существует для максимально быстрой сборки, чтобы получить максимально быстрый фидбек на изменения в коде staging - для ручного тестирования, сборка проходит медленнее за счет минимизации, но без нее не получится отловить определенный тип багов stagingAutoTest - для авто тестирования, позволяет в тестах дополнительно проверять результат работы r8, а также подключает release source set release - для заливки в магазин      Релизная подпись Минимизация Обфускация Avito Settings Charles proxy SourceSet     debug нет нет нет да да debug   staging нет да нет да да debug   stagingAutoTest нет да нет нет ? release   release да да да нет нет release    Релизная подпись Подпись может влиять на настройки разных 3rd party API. Например карты google привязаны к определенной подписи, и без нее могут не показываться вовсе, если также не зарегистрирован API карт на debug ключ.\nПримеры других зависимостей: рекламные SDK, социальные сети.\nМинимизация Используется, чтобы уменьшить размер архива с приложением, выпилив оттуда неиспользуемый код. Правила по которым определяется что есть используемый код могут быть ошибочны, так что тестировать следует приложение после минимизации\nКак запустить автотесты на сборке с минимизацией\nОбфускация Используется, чтобы запутать взломщиков, в общем случае не должно влиять на корректность кода.\nAvito Settings Дополнительное приложение с набором настроек для помощи в ручном тестировании\nCharles Proxy Прокси для помощи в тестировании приложения. Статья в CF (internal)\n"});index.add({'id':12,'href':'/avito-android/docs/assemble/buildmetrics/','title':"BuildMetrics",'content':"Метрики сборки Собираем с каждой сборки:\n Время сборки Время конфигурации проекта Эффективность кеширования  Собираем каждую метрику со следующими атрибутами:\n Успешная\\упавшая сборка Окружение: локальная сборка или CI Пользователь (для локальных сборок) Имя хоста (для сборок в CI)  Часть метрик доступна с большей детализацией:\n Аргументы запуска - какую задачу запускали Модуль  Dashboards (internal)  Время сборки  Общее время сборки Время сборки в разрезе пользователей и задач Бенчмарки Нестандартные настройки проекта   Статистика по задачам Время конфигурации Эффективность кеширования Общая статистика по сборкам  Реализация Собираем плагином com.avito.android.build-metrics (build-metrics).\n"});index.add({'id':13,'href':'/avito-android/docs/tech_radar/buildsrc/','title':"buildSrc in Gradle",'content':"buildSrc in Gradle Quadrant: tools\nStatus (ring): hold\nIt\u0026rsquo;s a default and convenient way for organizing custom plugins and tasks: Gradle - build sources.\nPros No binary versions and releases. It works as implicitly included build.\nCons Slows project synchronization in IDE At Avito, we had 6% of Kotlin code in buildSrc but it cost us about 40% of the time even with all possible optimizations.\nLack of support in IDEA Workaround: work with buildSrc as a standalone project.\nStruggle for reusing Gradle and Kotlin daemons As a result you waste an extra RAM.\nExample for Gradle daemon: gradle/buildSrc#checkSameDaemonArgs\nSlows configuration time Workaround:\n Use remote build cache and keep track a hit rate Exclude compilation of tests in buildSrc in local builds Run tests in buildSrc only in CI  Can\u0026rsquo;t reuse a module from buildSrc Technically, you can point directly to a jar from any buildSrc module. This way has limitations:\n IDE knows nothing about it and shows \u0026ldquo;Unsupported module\u0026rdquo; warning Requires buildSrc recompilation after changes It\u0026rsquo;s hard to support transitive dependencies  Harmful for compile avoidance Compiled classes from buildSrc will be added to a build script classpath. It can cause extra cache misses and recompilation after changes.\nRecommendations Certainly it\u0026rsquo;s a better place for custom plugins, tasks, logic than build-scripts. If you have loads of code or heavy integration tests in plugins, consider moving them to a standalone project.\n"});index.add({'id':14,'href':'/avito-android/categories/','title':"Categories",'content':""});index.add({'id':15,'href':'/avito-android/docs/ci/cigradleplugin/','title':"CI Gradle Plugin",'content':"CI Gradle plugin Для настройки CI под конкретный Gradle модуль используется in-house плагин.\nРешает задачу точечной настройки типа и строгости проверок для разных сценариев.\nplugins { id(\u0026#34;com.avito.android.cd\u0026#34;) } builds { ... } Применяется например в модуле приложения, однако нет никаких ограничений, чтобы применить плагин как-то иначе (см. ./build.gradle)\nBuilds Используется набор захардкоженых сценариев(builds):\nbuilds { fastCheck { ... } }  localCheck - проверки компиляции на локальной машине fastCheck - максимально быстрые проверки, выполняющие требования к CI fullCheck - максимально полные проверки, можем жертвовать скоростью release - набор действий необходимых для предоставления всех релизных артефактов  Steps Внутри сценариев описываем декларативно необходимые шаги:\nfastCheck { uiTests {} }  configuration - проверить конфигурацию проекта, модуль build-script-test uiTests - запустить ui тесты модуля performanceTests - запустить перформанс тесты модуля  fastCheck { performanceTests { configuration = \u0026#34;configuration name\u0026#34; enabled = true // true by default  } } enabled - запускать ли шаг.\nconfiguration - имя performance конфигурации, которая объявленна в instrumentation plugin\n compileUiTests - скомпилировать androidTest модуля unitTests - запустить юнит тесты модуля и всех его зависимостей lint - запустить android lint по настройкам в модуле docsDeploy - опубликовать документацию в k8s (отключено) docsCheck - запустить проверки документации uploadToQapps - загрузить указанные артефакты в QApps uploadToArtifactory - загрузить указанные артефакты в Artifactory uploadToProsector - загрузить указанные артефакты в Prosector (internal) uploadBuildResult - загрузить указанные артефакты в сервис релизов deploy - загрузить указанные артефакты в google play artifacts - зарегистрировать артефакты в качестве результатов билда.\nДобавит проверку на их наличие и возможность загрузить при помощи других тасок.  Сценарий может использовать Impact analysis(по-умолчанию отключено):\nfastCheck { uiTests { useImpactAnalysis = true } } SuppressibleBuildStep В разных сценариях падения шагов могут ронять за собой весь билд, а можно настроить чтобы билд не упал. Обработка этого флага должна быть явно поддержана шагом.\nfastCheck { uiTests { suppressFailures = false } } release { uiTests { suppressFailures = true } } Custom steps По необходимости добавляем свои шаги, наследуясь от BuildStep\nArtifacts Артефакты, которые планируется как-то использовать нужно зарегистрировать специальным образом\nartifacts { file(\u0026#34;lintReport\u0026#34;, \u0026#34;${project.buildDir}/reports/lint-results-release.html\u0026#34;) } Есть разные типы артефактов, различаются по типам проверок и способу описания путей\n apk - достает apk по buildType и проверяют пакет и подпись bundle - достает bundle по buildType и проверяют пакет и подпись mapping - достает mapping по buildType и проверяют наличие file - простой доступ к файлу по пути и проверка на наличие  artifacts { apk(\u0026#34;releaseApk\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, apkPath(\u0026#34;release\u0026#34;)) { signature = releaseSha1 } bundle(\u0026#34;releaseBundle\u0026#34;, RELEASE, \u0026#34;com.avito.android\u0026#34;, bundlePath(\u0026#34;release\u0026#34;)) { signature = releaseSha1 } mapping(\u0026#34;releaseMapping\u0026#34;, RELEASE, \u0026#34;${project.buildDir}/outputs/mapping/release/mapping.txt\u0026#34;) file(\u0026#34;featureTogglesJson\u0026#34;, \u0026#34;${project.buildDir}/reports/feature_toggles.json\u0026#34;) } Первый аргумент - регистрирует ключ, который затем используется в upload шагах для указания артефактов\n"});index.add({'id':16,'href':'/avito-android/docs/ci/civalues/','title':"CI Values",'content':"Требования к Continuous Integration Польза Проверки помогают не допускать ошибки\nСкорость получения фидбека Ожидаем что билд идет не больше 30 минут\nПонятность фидбека При падении однозначно понимаем в чем проблема\nНет лишнего шума (бесполезных warning'ов на которые неизвестно как реагировать)\nДетерминизм Запуски на том же коммите должны приводить к одинаковым результатам\n"});index.add({'id':17,'href':'/avito-android/docs/ci/impactanalysis/','title':"Code review",'content':"Impact analysis Импакт анализ находит измененные файлы и запускает минимально возможный набор проверок. Это всегда баланс между скоростью проверок и их полнотой.\nОписание подхода: The Rise of Test Impact Analysis\nUI тесты Обзор реализации для автотестов: Android CI Impact analysis.\nИмпакт анализу нужна помощь в привязке экрана к модулю. Для этого проставляем Screen.rootId.\nОграничения В импакт анализе есть два типа ошибок:\n Не запустили, то что было задето. Запустили больше, чем было задето (fallback).\nОтдаем этому варианту предпочтение.  Известные сценарии fallback'ов:\n Точность до уровня теста: если задет класс, запустим все его тесты. Точность до уровня модуля: если задет модуль, запустим все тесты связанные с package этого модуля. Запустим все тесты связанные с Screen, если не можем найти его package:  Screen не соответствует ни одному пакету Screen соответствует нескольким пакетам    "});index.add({'id':18,'href':'/avito-android/docs/contributing/codereview/','title':"Code review",'content':"Code review / Pull request Инспекция кода проводится для всех изменений в репозитории. Она проводится при отправке изменений в любую ветку, кроме feature. Просмотр и одобрение кода доступно всем разработчикам, но на отправку кода в develop, master накладываются ограничения.\nЦели инспекции кода Улучшение качества кода и продукта:\n Поиск и устранение ошибок и уязвимостей Оценка поддерживаемости, удобства использования Проверка на соответствие принятым стандартам (того, что невозможно или нецелесообразно автоматизировать)  Для команды:\n Совместное владение кодом, уменьшение фактора автобуса Обучение и наставничество Развитие культуры команды  Best practices Избегаем крупных PR Большие изменения делают неэффективной инспекцию кода, порождают конфликты. Применяем следующие подходы:\n Декомпозируем задачу и делаем в отдельных ветках, сливая более мелкими частями При возможности используем feature toggle, чтобы не держать долгоживущие ветки Изменения общих классов стараемся заранее выносить в отдельный PR. Например, начал делать задачу и видишь что нужно сильно менять модель данных. Лучше сделать это отдельным рефакторингом до реализации бизнес-функциональности.  Основная идея: develop играет роль CI при реализации задач. Лучше уменьшать интгерационные проблемы, сливать чаще, меньшими частями, работать на упреждение. Принимаем определенные риски, но размываем их по мелким задачам, так с ними проще бороться.\nПравило бойскаута или оппортунистический рефакторинг Opportunistic refactoring (Martin Fowler).\nПри необходимости рефакторинга стараемся заложить его в оценку бизнес-задачи, не откладывать на потом. Если совсем небольшой, то можно прямо в основной задаче, но желательно отдельным коммитом.\nНе переходи на личности. Обсуждай код, но не автора Это правило трудно переоценить, но оно лишь необходимое, но не достаточное условие. Даже в этом случае критика может быть принята в отношении человека. Нужно уметь критиковать, доносить предложения.\nБез оскорблений и ругательств У всех разное чувство юмора и поэтому даже безобидные на первый взгляд выражения могут быть восприняты оскорбительно.\nБез требовательных и вызывающих выражений Если смысл комментария можно свести к фразе \u0026ldquo;ты неправ\u0026rdquo;, например:\n \u0026ldquo;Так не сработает\u0026rdquo; \u0026ldquo;Совершенно неправильно\u0026rdquo; \u0026ldquo;Почему ты просто не …?\u0026rdquo;  Это неконструктивно, как минимум. Необходимо объяснить суть претензии, предложить решение.\nНе будь пассивно-агрессивным Не надо демонстрировать раздражение, избегай неприятных фраз и претензий:\n \u0026ldquo;Ещё раз повторяю: здесь нужно…\u0026rdquo; \u0026ldquo;Как я уже говорил…\u0026rdquo; \u0026ldquo;Как скажешь, делай как хочешь\u0026rdquo; \u0026ldquo;Если кому-нибудь вообще интересно, …\u0026rdquo;  Не нарушай правило «Никаких сюрпризов» Избегаем неожиданностей. Требования должны быть явные и зафиксированы в соглашениях.\nНе будь непрошенным советчиком Целью рецензирования не должно стать принуждение написать код так, как бы тебе хотелось. Уважай право автора на собственные решения, если они обоснованы. Главное — качественный, удобный в сопровождении код. Слишком много обсуждений не по существу скорее запутают, отвлекут от важного.\nУчитывай свои цели Всегда принимай во внимание то, чего хочешь достичь комментарием? Указать на конкретную проблему в коде? Помочь или подсказать? Или может быть только показать какой ты умный и подтвердить свою правоту? Иногда лучше держать своё мнение при себе.\nХвали хороший код Положительные комментарии хороших решений помогают лучше реагировать на критику, снимают напряженность в общении. Только без наигранности и слащавости, комментировать решения по сути. Также можно комментировать логику, свое понимание изменений (монолог на ходу). Это дает дополнительный шанс проверить корректность и понимание работы.\nИзбегай обвинений Лучше спрашивать, а не обвинять и делать громкие заявления. Это улучшает восприятие, направляет в сторону решения, а не рефлекторной обороны от обвинений. Будь осторожен с вопросами \u0026ldquo;Почему?\u0026quot;. Они могут звучать обвинительно.\n👎\n «Здесь ты не соблюдал стандарты» «А — неправильно, надо использовать В» «Запутанный код» «Ты не сделал X» «Почему ты просто не …?»   👍\n «Какие причины выбора такого решения?» «Зачем ты использовал A вместо B?» «Эта часть мне непонятна. Можешь объяснить?» «Я не нашёл, где сделано X» «Чем ты руководствовался, когда …?»    Объясняй причину Поясняй причину, что конкретно улучшит предлагаемое изменение.\nWorkflow Создание PR  PR создается после реализации функциональных требований. Для декомпозиции и уменьшения PR используем отдельные [под]задачи. Допустимо создание промежуточных PR для небольших рефакторингов, но декомпозиция работ должна быть осмысленная. Это не должно приводить к грязному develop. Все это обязательно комментируем. Иначе такой PR формально можно отклонить как недоделанный. Рекомендуется превентивно прокомментировать неочевидные места, пояснить решения, чтобы рецензенты лучше вникли в суть задачи и проверили более качественно. При необходимости, в описании PR можно пометить (в свободной форме) возможность слияния. По умолчанию это может делать только создатель.  Рецензенты (reviewers) Любой PR необходимо смотреть и комментировать всем членам команды. Это важный способ обмена знаниями. По умолчанию, при создании PR, список рецензентов пустой. Но можно указать желаемых участников.\nПеред началом просмотра Добавить себя в список рецензентов. Так обозначаем, что начали рецензирование. При невозможности закончить, необходимо удалить себя из списка рецензентов.\nВ процессе Что проверяем?\n  Соответствие принятым стандартам и соглашениям\n  PR содержит изменения только по заявленной в задаче функциональности\n  По возможности, сразу создаем задачи с конкретными предложениями. Это удобное средство, упрощающее отслеживание исправлений. Нельзя слить PR, если в нем есть незавершенные задачи.\n  Комментарии, не требующие никакой ответной реакции, являются исключением и помечаются специально. Для них пишем \u0026ldquo;FYI \u0026hellip;\u0026rdquo;\n  Неактуальные комментарии можно не удалять, а оставлять намеренно в угоду сохранения истории обсуждения. Подобные комментарии могут быть маркером неочевидных решений, плохо читаемого кода и т.п.\n  По окончании Явно отражаем бинарный результат:\n Approve - можно сливать, полностью устраивает в таком виде. Needs Work - требуются доработки (любые).  Этот статус не надо рассматривать как оценку качества.\nОн лишь констатирует факт - сливать в таком виде еще нельзя.\nРекомендуется ставить при наличии любых блокеров (конфликты, открытые задачи, \u0026hellip;). Мотивация: если в PR отмечено что можно сливать и все поставят апрувы при наличии открытых задача, то после закрытия задач можно случайно смержить еще до пуша исправлений. Поэтому апрув должен быть явный, не впрок.\nDecline неудобен тем, что теряется история обсуждений. Используем только если хотим полностью отменить PR.\nАвтор По каждому комментарию дает обратную связь:\n Исправить код, если все очевидно. Краткое описание изменений удобно делать в задачах. По каждому исправлению необходимо дать ответ, что и как именно исправлено (рекомендуется выразить это задачей). Если что-то сделано намеренно, то необходимо пояснить причины. На открытые вопросы необходимо дать ответы.  При наличии одобрения от всех рецензентов сливает изменения.\nПроблемные сценарии Случайное бекпортирование при слиянии в несколько веток - создавать PR последовательно:\nСначала сливаем в \u0026ldquo;более стабильную” (release и т.п.) ветку, исправляем замечания и т.п.\nПотом сливаем в \u0026ldquo;более новую\u0026rdquo; (develop) ветку, уменьшая риск случайного бэкпортирования.\nPR в более стабильные ветки необходимо создавать сразу, не откладывать на потом. Конфликты лучше решать сразу, не накапливать.\nДругое В описании PR, относящихся к задачам по обновлению версии библиотек, необходимо указывать What\u0026rsquo;s new для новой версии библиотеки.\nМотивация: предоставить рецензентам весь контекст, чтобы обсуждать более предметно.\nМатериалы по теме  Как подписаться на изменения в модулях? Code Ownership Plugin (internal) Рекомендации Google: How to do a code review  "});index.add({'id':19,'href':'/avito-android/docs/contributing/codestyle/','title':"Code style",'content':"Code Style Автоматизация Editor config За настройку code style отвечает editor config. А точнее плагин для IDE.\nНужно убедиться, что плагин установлен и включен (Preferences \u0026gt; Plugins \u0026gt; Installed \u0026gt; search: EditorConfig)\nПосле этого все настройки авто-формата должны применяться по порядку:\n EditorConfig настройка на уровне папки EditorConfig настройка на уровне проекта Личная настройка в IDE (если не определены настройки выше)  Правила определены в .editorconfig в корне проекта. И переопределены в папках где значения по-умолчанию не устраивают (например ci/docker/android-builder/.editorconfig).\n.idea/codeStyles (legacy) Отказались от использования xml, которые сохраняет IDE. Разные версии Android Studio автоматически вносят изменения в файл настроек и это невозможно отключить. Как итог, получали нежелательные и конфликтующие изменения. Это отвлекает и мешает использовать разные версии IDE.\nЕсли автоматика сломалась Порой по разным причинам автоматические настройки code style слетают, это больное место в Android Studio. Причиной может быть к примеру обновление версии.\nВыставить настройки близкие к автоматическим можно так:\n Preferences -\u0026gt; Editor -\u0026gt; Code Style установить Hard wrap - 120 Preferences -\u0026gt; Editor -\u0026gt; Code Style -\u0026gt; Kotlin  Set From -\u0026gt; Predefined Style -\u0026gt; Kotlin Style Guide Imports -\u0026gt; Use single name import в обоих опциях Imports -\u0026gt; Packages to Use Imports with * - удалить все    Проверки в CI В данный момент соответствия code style проверяются вручную на Code Review (Задача на автоматизацию - MBS-6991 (internal)).\nCode guidelines Именование Packages  Не должен содержать заглавные символы, чтобы избегать конфликтов с интерфейсами и классами. Допускается использования символа _  С точки зрения бизнес-модулей стараемся делать плоскую структуру пакетов, не привязываясь к навигации. Примеры:\n categories вместо category/list  Variables  Детальность названия должна соответствовать области видимости. Не экономим на буквах в ущерб читаемости. Сокращения допустимы для общепринятых терминов.  val ctx: Context val context: Context  Имя должно отражать смысл. Избегаем излишних знаний про реализацию и тип данных.  val bundle: Bundle val state: Bundle Kotlin Используем Kotlin official style guide\nFile structure Extension функции и свойства рекомендуется располагать в файле с названием расширяемого класса во множественном числе. Исключение: Если extension относится к типизированной коллекции, то он должен располагаться в файле с названием типа а не коллекции. Мотивация: однозначный поиск, не нужно думать куда это положили. Пример:\nViews.kt: fun View.hide() = ... Dimensions.kt: fun List\u0026lt;Dimension\u0026gt;.findByRatio() = ... Lists.kt: fun List\u0026lt;T\u0026gt;.second() = ... Публичные классы и файлы В файле должно быть не более одного публичного класса\\интерфейса\\аннотации... Исключение делаем для вырожденных реализаций интерфейса, которым нельзя придумать осмысленного именования и из-за этого не может быть нескольких имплементаций (...Impl и т.п.).\nМотивация: нужны простые и однозначные правила для навигации, иначе имя файла становится бесполезным. Если каждый будет располагать согласно предпочтениям, то это может привести к бесконечному рефакторингу и лишним спорам.\nКонстанты Константные значения на уровне файла называем в нотации ALL_UPPER_CASE. Значения для строковых констант по возможности пишем в snake_case. Не мусорим в пространстве имен: обязательно используем минимально возможную видимость (private если используется только в этом файле, internal если используется только в пределах модуля). Примитивные значения и строки дополнительно помечаем модификатором const\nprivate const val KEY_MESSAGE = “key_fragment_message\u0026#34; internal const val INVALID_POSTIION = Int.MIN_VALUE Аргументы функций Неочевидные аргументы необходимо именовать при вызове.\nPlatform types Избегаем платформенные типы. При взаимодействии с Java кодом указывать типы явно, чтобы избежать потенциальных ошибок.\nval fooId = arguments.getString(KEY_FOO_ID) // --\u0026gt; String! val fooId: String? = arguments.getString(KEY_FOO_ID) // --\u0026gt; String? Reified type parameters При наличии альтернативы предпочтительно вывести тип автоматически, средствами языка, чтобы избежать возможных ошибок при приведении типа:\nval location = readParcelable(Profile::class.java.classLoader) val location = readParcelable() Комментарии Комментирование кода Комментариев избегаем. Используем только для пояснения неочевидных моментов, но максимально пытаемся выразить смысл кодом. Временное комментирование кода допускается в feature ветках. От неиспользуемого кода избавляемся и не пытаемся использовать комментарии вместо VCS. Мотивация: устаревание комментариев, они начинают врать, а это хуже чем их отсутствие.\nПри необходимости временно закомментировать участок кода предпочтительно использовать // комментарии вместо /* */. Мотивация: проще редактировать, т.к. у каждой строки нет \u0026ldquo;контекста\u0026rdquo;. Например, проблемно раскомментировать несколько строк внутри /* */ комментария.\nКомментирование решений При необходимости пояснить решение избегаем комментарии. Необходимо выражать смысл кодом - в названиях переменных, методов и т.п. Пример - дублирование if, который не поясняет смысл проверки. Мотивация: код должен быть самодокументируемым. Комментарии легко устаревают, становятся ложными и могут даже навредить, введя в заблуждение (см. Clean Code)\nTODO комментарии Допускаются комментарии вида // TODO comment Обязательно наличие пояснения. Rule of thumb: из комментария сразу должна быть понятна суть. Иначе этот комментарий не нужен.\nDeprecations Когда в коде появляется новый класс или метод, который дублирует функции уже существующего, то желательно удалять старый. Если такой возможности нет, то помечаем старый класс или метод аннотацией @Deprecated, но обязательно с комментарием и указателем на новый. Для kotlin аннотации @Deprecated обязательными для заполнения параметрами являются message и replaceWith.\nImports Fully qualify imports This is bad: import foo.* This is good: import foo.Bar Мотивация: используемые зависимости очевидны, меньше конфликтов. Читаемость и поддерживаемость важнее. Источник\nOrdering Порядок методов и полей Публичное преимущественно располагаем в начале класса, приватное и с большей детализацией - ниже. Метод должен быть при возможности сразу после места его использования. Мотивация: основная цель - обеспечить хорошую читаемость кода. В идеале код должен читаться как рассказ. Для этого надо минимизировать навигацию при чтении.\nXML Размеры, отступы и кегли шрифтов выносим в dimens.xml, если они повторяются или имеют разные значения для разных конфигураций экранов. Даем осмысленные имена в snake_case. Пример: \u0026lt;dimen name=\u0026quot;list_card_vertical_padding\u0026quot;\u0026gt;4dp\u0026lt;/dimen\u0026gt; Мотивация: быстрая адаптация верстки к различным экранам.\nLayout называем придерживаясь правила \u0026lt;where\u0026gt;[_\u0026lt;description\u0026gt;].xml\n \u0026lt;where\u0026gt; описывает экран или его логическую часть. \u0026lt;description\u0026gt; - необязательное описание. Может включать в себя маркеры типа: activity, fragment и тп.  Пример: profile_editor.xml, offer_common_part.xml, balance.xml, order_item.xml Мотивация: быстрая и удобная навигация в папках с ресурсами, благодаря переносу смысловой нагрузки в начало. order[_activity].xml вместо activity_order.xml\nС помощью FOLDING_PLUGIN, можно добиться групирования по виртуальным папкам.\nview id именуем в snake_case. Пример: android:id=\u0026quot;@+id/category_title\u0026quot;.\nСтили называем в PascalCase. Пример: \u0026lt;style name=\u0026quot;AvitoButton.Transparent\u0026quot;\u0026gt;.\n"});index.add({'id':20,'href':'/avito-android/docs/contacts/','title':"Contacts",'content':"Contacts Public channels Telegram chat (Russian)\nInternal channels Slack:\n #android-dev - single slack channel for any android related stuff #android-autotesting - all about testing #speed  Issues:\nWe track our issues in MBS project.\n"});index.add({'id':21,'href':'/avito-android/docs/ci/customgradleplugins/','title':"Custom Gradle Plugins",'content':"Custom Gradle plugins Вся логика CI расположена в in-house Gradle плагинах. Для тестирования корневого проекта смотри модуль build-script-test.\nHow to start Начни с официальных туториалов, они сэкономят время:\n Gradle plugin development tutorials\nДля нас не актуальна только публикация плагинов. Custom tasks  Если что-то не понятно, здесь тебе помогут:\n #gradle (internal) gradle-community.slack.com  Работа с плагинами в IDE  Предпочтительно использовать IntelliJ IDEA Import project Согласись использовать Gradle wrapper Settings \u0026gt; Build, Execution, Deployment \u0026gt; Build Tools \u0026gt; Gradle \u0026gt; Runner  Delegate IDE build/run actions to Gradle (check) Run tests using : Gradle Test Runner    Теперь можно запускать тесты по иконкам run\nKnown issues:\n Имя теста (DynamicTest.displayName) некорректно отображается в IDE: #5975  Debugging Для тестов работает из IDE.\nДля отладки плагина:\n Добавь в IDE конфигурацию Remote для запуска, как для обычного java проекта. Запускай Gradle из корня репозитория с параметрами -Dorg.gradle.debug=true --no-daemon  Debugger работает не только в нашем коде, остановиться можно и в AGP или Gradle.\nTesting Gradle plugins Isolating business-logic for unit-tests You can isolate most of the logic from Gradle. Thus, it can be covered easily by unit-tests.\nabstract class FeatureTask @Inject constructor( private val workerExecutor: WorkerExecutor ) : DefaultTask() { @TaskAction fun action() { val apiConfig = ... // get from the project  workerExecutor.noIsolation().submit(FeatureWorkerAction::class.java) { parameters -\u0026gt; parameters.getIntegrationApiConfig().set(apiConfig) } } } // This wrapper is needed only for Worker API // It can be started in another process. Thus, it has to prepare dependencies for the real work.  abstract class FeatureWorkerAction : WorkAction\u0026lt;Parameters\u0026gt; { interface Parameters : WorkParameters { fun getIntegrationApiConfig(): Property\u0026lt;IntegrationApiConfig\u0026gt; } override fun execute() { val api = IntegrationApiConfig.Impl(parameters.getIntegrationApiConfig().get()) val action = FeatureAction( integrationApi = api ) action.execute() } } // This class is responsible for the real work. // The less it knows about Gradle, the better.  class FeatureAction( private val integrationApi: IntegrationApi ) { fun execute() { // Do the real work here  } } // Now you can use simple mocks to test the action. @Test fun test() { val integrationApi = mock\u0026lt;IntegrationApi\u0026gt;() whenever(integrationApi.foo).thenReturn(bar()) val action = FeatureAction(integrationApi) \u0026lt;-- No Gradle abstractions here action.execute() assertThat(...) } Integration tests For simple cases you can create dummy instance of Project by ProjectBuilder\nval project = ProjectBuilder.builder().build() val task = project.tasks.register\u0026lt;TestTask\u0026gt;(\u0026#34;testTask\u0026#34;) {} task.get().doStuff() When you need to run a real build, use Gradle Test Kit.\nSee ready utilities in :test-project module.\nЗапуск тестов из консоли ./gradlew test\nЧтобы не останавливать прогон тестов на первом падении добавь --continue\nДля запуска отдельного теста, класса или пакета работает фильтр: --tests package.class.method, но нужно запускать тесты для отдельного модуля, иначе фильтр упадет не найдя нужных тестов по фильтру в первом попавшемся модуле.\nBest practices Fail-fast contract Each plugin should check preconditions as early as possible. If some parameter is missing or has invalid value, the plugin should fail and explain the reason.\nFeature toggles Плагин может сломаться и заблокировать всем работу с проектом. Чтобы дать себе время на исправление, делай плагин отключаемым:\nopen class MyPlugin : Plugin\u0026lt;Project\u0026gt; { override fun apply(project: Project) { // В каждом property используем префикс `avito.\u0026lt;plugin\u0026gt;`  // сразу видно где используется  if (!project.getBooleanProperty(\u0026#34;avito.my_plugin.enabled\u0026#34;, default = false)) { project.logger.lifecycle(\u0026#34;My plugin is disabled\u0026#34;) return } Тогда каждый разработчик сможет локально отключить плагин в случае проблем.\nДиректория ci Там храним всю интеграцию с CI.\nЧасто нужно править плагин совместно с ./ci/\nЧтобы работать одновременно со всем этим кодом, к уже открытому проекту добавь модуль ci: File \u0026gt; New \u0026gt; Module from existing sources \u0026gt; путь до папки ci \u0026gt; ok \u0026gt; ok\nИнтеграция плагина в CI CI Gradle Plugin\nДополнительные материалы  Интеграция с AGP 4+  "});index.add({'id':22,'href':'/avito-android/docs/assemble/dependencies/','title':"Dependencies",'content':"Зависимости Как подключить внешнюю зависимость? Все зависимости объявляем в одном файле - Dependencies.kt.\nНа них ссылаемся в build.gradle модуля:\ndependencies { implementation(Dependencies.supportAnnotations) Как зафорсить версию зависимости? Конфигурация проекта упадет, если в транзитивных зависимостях прилетают разные версии одной и той-же библиотеки:\n\u0026gt; Conflict(s) found for the following module(s): - com.google.android.gms:play-services-measurement-api between versions 17.2.1 and 17.0.0 Run with: --scan or :avito:dependencyInsight --configuration debugRuntimeClasspath --dependency com.google.android.gms:play-services-measurement-api to get more insight on how to solve the conflict. В приложении должна быть только одна версия.\nВыбери подходящую версию (обычно берем старшую) и добавь зависимость в Dependencies.\nАвтоматически форсим версии для всех зависимостей из Dependencies (см. applyDefaultResolutionStrategy).\n"});index.add({'id':23,'href':'/avito-android/docs/architecture/dagger/','title':"Dependency Injection with Dagger",'content':"Dagger Материалы Обязательно прочесть  Документация Тредик на гитхабе с tips \u0026amp; tricks для kotlin  Рекомендую к изучению  Видео от одного из авторов Dagger Ron Shapiro, о том, как правильно его готовить Немного устаревшая статья про правильное приготовление dagger  ⚠️ Нельзя постигнуть даггер, не смотря какой код он генерирует!  Как правильно работать с Dagger  Поддерживаемость прежде всего. Граф зависимостей делай маскимально простой и понятный Application Component имеет минимальный скоуп - содержит не более необходимого чилсла зависимостей Если зависимость может быть не глобальной, оне должа быть в скоупе экрана, а не приложения Меньше мокай в instrumentation-тестах  Provides → Binds Используй Binds вместо Provides по-возможности всегда\n👍 Dagger генерирует меньше классов и получается более эффективный код.\n👍 Проще писать Module-классы и изменять код, как в конструкторах, так и в Module-классах.\nВ самом простом случае необходимо добавить к объявлению класса @Inject constructor и переделать метод класса на абстрактный, который связывает интерфейс и реализацию:\nБыло:\n@Provides @PerFragment internal fun provideSearchDeepLinkInteractor( api: SearchApi, searchParamsConverter: SearchParamsConverter, schedulersFactory: SchedulersFactory ): SearchDeepLinkInteractor { return SearchDeepLinkInteractorImpl(api, searchParamsConverter, schedulersFactory) } Стало:\n@Binds @PerFragment fun bindsSearchDeepLinkInteractor(interactor: SearchDeepLinkInteractorImpl): SearchDeepLinkInteractor Было:\nclass SearchDeepLinkInteractorImpl( private val api: SearchApi, private val searchParamsConverter: SearchParamsConverter, private val schedulers: SchedulersFactory ) : SearchDeepLinkInteractor Стало:\nclass SearchDeepLinkInteractorImpl @Inject constructor( private val api: SearchApi, private val searchParamsConverter: SearchParamsConverter, private val schedulers: SchedulersFactory ) : SearchDeepLinkInteractor Когда использовать @Provides Когда идет любое конфигурирование/инициализация, например features. Dagger - инструмент DI. Старайтесь минимально заниматься решением задач не связанных с DI через Dagger. Меньше кода в Dagger-модуле - лучше.\n@Provides @PerFragment internal fun providePermissionHelper(features: Features, dialogRouter: DialogRouter): PermissionHelper { val permissionHelper = FragmentPermissionHelper(fragment) return if (features.geoPermissionDialog.value) { LocationPermissionHelperWrapper(permissionHelper, dialogRouter) } else { permissionHelper } } Если нужно мокать методы модуля для тестирования. Мокать binds-методы не имеет смысла - это просто источник информации для процессора Dagger.\nИнстанциирование сторонних классов. Невозможно прописать Inject в конструктор класса, к исходному коду которого нет доступа.\n@Provides @JvmStatic internal fun provideAdapterPresenter(provider: ItemBinder): AdapterPresenter { return SimpleAdapterPresenter(provider, provider) } Static providers: object При использовании @Provides объявляй класс object.\n👍 В этом случае R8 удалит всю инициализацию и может заинлайнить методы (они будут действительно статическими).\n@Module object Module { @Provides fun provideObject(): Object { return Object() } } 👎 Нельзя мокать модули в тестах, что не часто нужно.\nIntoSet / IntoMap Используй IntoSet (IntoMap). Проставь JvmSuppressWildcards, чтобы Dagger понял какого типа вам нужны данные.\n👍 Позволяет в разных модулях собирать необходимые вам объекты в список.\nЧтобы подключить новый класс и он долетел куда нужно достаточно соблюсти интерфейс, и добавить IntoSet (IntoMap) @Binds @IntoSet fun bindCategorySettingsItemBlueprint(blueprint: CategorySettingsItemBlueprint): ItemBlueprint\u0026lt;*, *\u0026gt; @Binds @IntoSet fun bindLogoWithVersionSettingsItemBlueprint(blueprint: LogoWithVersionSettingsItemBlueprint): ItemBlueprint\u0026lt;*, *\u0026gt; @Provides @PerActivity internal fun provideItemBinder( blueprints: Set\u0026lt;@JvmSuppressWildcards ItemBlueprint\u0026lt;*, *\u0026gt;\u0026gt; ): ItemBinder { return with(ItemBinder.Builder()) { blueprints.forEach { registerItem(it) } build() } } 👎 В сложной иерархии модулей может потеряться контроль над тем, что прилетает из графа dagger.\n👎 Необходимо использовать квалификтаторы (Named), в случае если интерфейсы клэшатся и нужно сделать два набора данных\nScope overuse Не злоупотребляй скоупами без надобности.\nКаждый скоуп, кроме Reusable (Singleton, PerActivity, PerFragment, etc) порождает использование Dagger-класса DoubleCheck, который реализует проверку DoubleCheckLock для гарантий Singleton.\npublic T get() { Object result = instance; if (result == UNINITIALIZED) { synchronized (this) { result = instance; if (result == UNINITIALIZED) { result = provider.get(); instance = reentrantCheck(instance, result); /* Null out the reference to the provider. We are never going to need it again, so we * can make it eligible for GC. */ provider = null; } } } return (T) result; } Reusable scope порождает проверку SingleCheck, которая менее строгая:\npublic T get() { Object local = instance; if (local == UNINITIALIZED) { // provider is volatile and might become null after the check, so retrieve the provider first  Provider\u0026lt;T\u0026gt; providerReference = provider; if (providerReference == null) { // The provider was null, so the instance must already be set  local = instance; } else { local = providerReference.get(); instance = local; // Null out the reference to the provider. We are never going to need it again, so we can  // make it eligible for GC.  provider = null; } } return (T) local; } Component.Builder → Component-Factory 👍 Ошибка когда при создании компонента забывают вызвать один из методов билдера вылетит во время компиляции а не в рантайме.\nБыло:\ninterface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Builder interface Builder { fun settingsDependencies(settingsDependencies: SettingsDependencies): Builder fun locationDependencies(locationDependencies: LocationDependencies): Builder @BindsInstance fun state(state: Kundle?): Builder @BindsInstance fun resources(resources: Resources): Builder @BindsInstance fun settingsItemsStream(settingsItemsStream: PublishRelay\u0026lt;String\u0026gt;): Builder fun build(): SettingsComponent } } Стало:\ninterface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Builder { fun create( settingsDependencies: SettingsDependencies, locationDependencies: LocationDependencies, @BindsInstance state: Kundle?, @BindsInstance resources: Resources, @BindsInstance settingsItemsStream: PublishRelay\u0026lt;String\u0026gt; ): SettingsComponent } } Лучше именовать параметры при вызове, чтобы не перепутать, если есть аргументы одного типа идущие последовательно:\nDaggerSettingsComponent.factory() .create( settingsDependencies = findComponentDependencies(), locationDependencies = findComponentDependencies(), state = savedInstanceState?.getKundle(KEY_SETTINGS_PRESENTER), resources = resources, settingsItemsStream = PublishRelay.create() ) .inject(this) BindInstance → stateless module 👍 Вы сможете провайдить объект в дерево Dagger не добавляя его в конструктор модуля.\nЭто сделает его статическим, что хорошо. См. пункт 1 про статические провайдеры.\nБыло:\n@Component(modules = [SettingsModule::class]) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Factory { fun module(module: SettingsModule): Builder fun create(): SettingsComponent } } class SettingsModule(val kundle: Kundle) {...} Стало:\n@Component(modules = [SettingsModule::class]) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Factory { @BindsInstance fun create(state: Kundle?): Factory } } object :SettingsModule() {...} Хорошее правило:\n✅ Singleton (PerActivity, PerFragment), если важна гарантия единственности\n✅ Reusable - если singleton нужен для оптимизации\n✅ во всех остальных случаях избегайте скоупов Перевод субкомпонентов уровня Application в компоненты Проблема Subcomponents в сгенерированном коде - это вложенный класс в Component.\nПоэтому использовать subcomponent для фичей\\экранов дорого:\n Ломает compilation avoidance: каждое изменение субкомпонента приводит к перегенерации компонента в avito (самый тяжелый модуль с тестами). Хуже масштабируется: ApplicationComponent распухает, содержит все фичи, растет время его компиляции. Дольше инициализации ApplicationComponent  Решение  Не использовать subcomponent на уровне Application, выделить отдельные Dagger-компоненты в gradle-модулях. Внутри компонента на уровне модули использовать субкомпоненты уже не проблема, не аффектит все приложение.  Тогда основной даггер-граф из Application вообще может не перегенерироваться при изменении в gradle-модулях (бывшие субкомпоненты).\nАлгоритм  Выявить интерфейсы, которые нужны и будут прилетать из основного (application) дерева Dagger.\nНайти их можно по использованию. Они инжектятся напрямую, либо используются в модулях.\nЕсли сразу непонятно, какие интерфейсы понадобятся, можно сделать пустой интерфейс и заполнять его по мере того, как Dagger будет сообщать о том, что не хватает.  interface SettingsDependencies : ComponentDependencies { } Выделить их в отдельный интерфейс, отнаследовав от ComponentDependencies:\n⚠️ Это самый сложный этап, где Dagger ругается что ему не хватает из основного графа, а вы выписываете недостающее.\nДля часто используемых общих зависимостей выделили CoreComponentDependencies.  interface SettingsDependencies : ComponentDependencies { fun activityIntentFactory(): ActivityIntentFactory fun context(): Context fun startupStorage(): StartupStorage fun deviceIdProvider(): DeviceIdProvider fun schedulersFactory(): SchedulersFactory fun profileInfoStorage(): ProfileInfoStorage fun deviceMetrics(): DeviceMetrics fun debugIntentFactory(): DebugIntentFactory } Eсли используются дополнительные модули (например, SavedLocationInteractorModule), у них могут быть готовые интерфейсы:  interface LocationDependencies : ComponentDependencies { fun locationApi(): LocationApi fun savedLocationStorage(): SavedLocationStorage } Отнаследовать ApplicationComponent от интерфейсов из прошлых шагов:  interface ApplicationComponent : BaseApplicationComponent, LocationDependencies, SettingsDependencies, ... } Добавить в ComponentDependenciesModule маппинг нового ComponentDependencies:  @Binds @IntoMap @ComponentDependenciesKey(SettingsDependencies::class) abstract fun provideSettingsDependencies(component: ApplicationComponent): ComponentDependencies @Binds @IntoMap @ComponentDependenciesKey(LocationDependencies::class) abstract fun provideLocationDependencies(component: ApplicationComponent): ComponentDependencies Изменить субкомпонент на компонент, или создать новый такого вида:  @PerActivity @Component( dependencies = [SettingsDependencies::class, LocationDependencies::class], //Необходимые зависимости  modules = [SettingsModule::class, SavedLocationInteractorModule::class] //Необходимые модули ) interface SettingsComponent { fun inject(activity: SettingsActivity) @Component.Factory interface Builder { fun create( settingsDependencies: SettingsDependencies, locationDependencies: LocationDependencies, @BindsInstance state: Kundle?, @BindsInstance resources: Resources, @BindsInstance settingsItemsStream: PublishRelay\u0026lt;String\u0026gt; ): SettingsComponent } } В Activity/Fragment код изменится подобным образом:  import com.avito.android.di.findComponentDependencies import com.avito.android.DaggerSettingsComponent ... DaggerSettingsComponent.factory() .create( settingsDependencies = findComponentDependencies(), locationDependencies = findComponentDependencies(), state = savedInstanceState?.getKundle(KEY_SETTINGS_PRESENTER), resources = resources, settingsItemsStream = PublishRelay.create() ) .inject(this) ⚠️ Важно добавить в импортах перед SettingsComponent слово Dagger (DaggerSettingsComponent). Дело в том, что это кодогенерированный класс и на этапе написания кода он недоступен.\nСбилдить и запустить. Все готово!\nKnown Issues IDE не видит сгенерированные файлы Компонент отображается красным, как будто его нет.\n Проверь что файлы kapt не добавлены в исключения: Preferences \u0026gt; Editor \u0026gt; File Types \u0026gt; Ignore Files and Folders  Dagger: error.NonExistentClass cannot be provided / converted error.NonExistentClass cannot be provided without an @Inject constructor or an @Provides-annotated method e: MyClass.java:15: error: incompatible types: NonExistentClass cannot be converted to Annotation @error.NonExistentClass() ^ Dagger не видит этот класс из сгенерированного кода.\nПроверь что подключен соответствующий модуль с этим классом. Ошибка может врать, поэтому лучше проверить доступность всех классов, используемых в модуле.\n"});index.add({'id':24,'href':'/avito-android/docs/','title':"Docs",'content':""});index.add({'id':25,'href':'/avito-android/docs/contributing/docs/','title':"Documentation",'content':"Documentation If the documentation is not good enough, people will not use what you do.\nStyle guide Write simply and to the point Documentation is intended to solve problems. Thus, it has to be simple and clear.\nWe can recommend several definitive guides on writing in general:\n The Elements of Style - William Strunk Jr. Пиши, сокращай (glvrd.ru - online checker)  Extra materials about technical writing:\n Jetbrains - Как писать полезные технические тексты Microsoft Writing Style Guide GitLab documentation styleguide What nobody tells you about documentation  Use appropriate format for the problem There is no universal documentation. It needs to be structured around problem and a level of knowledge:\n    Studying Working     Practical steps Tutorial How-to guide   Theoretical knowledge Explanation Reference    It\u0026rsquo;s ok to mix some types in one page:\n# Managing X Here goes short _explanation_ of X for new users. You can reference here to a detailed information. If I know this topic, I will skip it easily. ## Create a new X 1. Do ... \u0026lt;-- Short how-to guide 1. ... ## Move files to X Select ... Tutorial Analogy: teaching a child how to cook\nNaming:\n Getting started with X Writing your first test    Assist newcomers to get started Is learning-oriented Shows how to do in form of a lesson  The tutorial declares a goal in the beginning. After it guides by a series of steps. Each step is:\n Easy to follow Robust and reliable Gives a positive feedback by an immediate result Has as minimum theory as possible  Examples:\n Creating Web Applications with Flask   How-to guide Analogy: a recipe\nNaming:\n How to run tests in CI - 👍 Running tests - 👎 Tests in CI - 👎     Ориентация на практический результат: как решить проблему.\n  Ключевое отличие от tutorial: уже знакомы с продуктом.\nМожет адресовать проблему, которую новички могут даже не сформулировать.\n  Не объясняет концепции, может только ссылаться при необходимости.\n  Читатель понимает чего хочет достичь, но не знает как.\n  Шаги не такие надежные и повторяемые, читатель уже знаком с продуктом.\n  Шаги более гибкие\n  Описание не обязано быть полным, только то что нужно для проблемы.\n    Explanation Analogy: an overview article\nNaming: \u0026ldquo;Testing infrastructure in CI\u0026rdquo;\n Ориентация на понимание, не решает конкретных практических задач.\nЭто самый свободный формат описания. Описывает концепции, поясняет контекст и историю развития Дает альтернативные подходы и мнения, поясняет мотивацию   Reference Analogy: an article in Wikipedia\n  Ориентация на информацию: описать как устроено, как работает.\n  Отличие от tutorial, how to guide: не фокусируется на решении конкретных проблем, хотя и может приводить примеры использования.\n  Структура продиктована кодом, повторяет его\n  Описывает детали в точности как они работают.\n  Объясняет ситуацию как есть, не уходит в дискуссии, мнения, инструкции. Такие отвлечения мешают понять как работает.\n    Structure Вся документация состоит из набора markdown файлов.\nИспользуем генератор статических сайтов Hugo (тема - Book).\nДля проверки стиля - markdownlint\nMenu on the left Меню редактируется в docs/content/menu/index.md\nLinks Абсолютная ссылка: {{\u0026lt; ref \u0026quot;/Name.md\u0026quot; \u0026gt;}}, где путь относителен директории content/.\nОтносительная ссылка: {{\u0026lt; relref \u0026quot;Name.md\u0026quot; \u0026gt;}}.\nAnchor: {{\u0026lt; ref \u0026quot;/Name.md#header\u0026quot; \u0026gt;}}.\nПодробнее: cross references\nInternal links Документация публичная, поэтому в ней ней не должно быть прямых ссылок на внутренние сервисы (issue tracker, CI, \u0026hellip;).\nЧтобы не терять эту информацию, используй links.k.avito.ru для редиректа.\nСсылки с кастомным путем должны указывать на что-то неизменяемое.\nПуть изменится, а ссылку уже не подменить.  Чтобы посмотреть статистику по ссылке, добавь к ней +.\nDiagrams Diagrams is a preferable way for schemes and processes.\nThey are cheaper in maintenance. Text is the source of truth.\nYou don\u0026rsquo;t need an original image and can edit it in a text editor.\nUse mermaid shortcode:\nLive editor\n{{\u0026lt;mermaid\u0026gt;}} stateDiagram [*] --\u0026gt; A A --\u0026gt; B B --\u0026gt; [*] {{\u0026lt;/mermaid\u0026gt;}}   stateDiagram [*] -- A A -- B B -- [*] Images Images are good for illustrating an explanation.\nUse any public file storage for them. For example, a Github CDN:\nThere is a html figure element for more control.\nHints {{\u0026lt; hint [info|warning|danger] \u0026gt;}} **Markdown content** Lorem markdownum insigne. Olympo signis Delphis! {{\u0026lt; /hint \u0026gt;}} Markdown content\nLorem markdownum insigne. Olympo signis Delphis!  Buttons {{\u0026lt; button relref=\u0026#34;/\u0026#34; \u0026gt;}}Home{{\u0026lt; /button \u0026gt;}} {{\u0026lt; button href=\u0026#34;http://repo/CONTRIBUTING.md\u0026#34; \u0026gt;}}Contribute{{\u0026lt; /button \u0026gt;}}  Home  Contribute  Tabs {{\u0026lt; tabs \u0026#34;Unique ID\u0026#34; \u0026gt;}} {{\u0026lt; tab \u0026#34;MacOS\u0026#34; \u0026gt;}} MacOS Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Linux\u0026#34; \u0026gt;}} Linux Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; tab \u0026#34;Windows\u0026#34; \u0026gt;}} Windows Content {{\u0026lt; /tab \u0026gt;}} {{\u0026lt; /tabs \u0026gt;}}  MacOS  MacOS Content  Linux  Linux Content  Windows  Windows Content   Columns {{\u0026lt; columns \u0026gt;}} Left Content \u0026lt;---\u0026gt; Right Content {{\u0026lt; /columns \u0026gt;}} Left Content  Right Content   Expand {{\u0026lt; expand \u0026#34;Title\u0026#34; \u0026gt;}} Markdown content {{\u0026lt; /expand \u0026gt;}}  Title ↕  Markdown content    Math KaTeX\n{{\u0026lt; katex \u0026gt;}} \\overline{a \\lor b} = \\overline{a} \\land \\overline{b} {{\u0026lt; /katex \u0026gt;}}    \\( \\overline{a \\lor b} = \\overline{a} \\land \\overline{b} \\)  Lists Нумерованный или ненумерованный Используй нумерованный список только если он описывает последовательность шагов.\n👎\nСистема состоит из следующих компонентов: 1. `Collector` 1. `Publisher`   👍\nЗапусти команды: 1. `cd dir` 1. `./prepare_data.sh` 1. `./publish_results.sh`    Language Interaction with UI  Use bold text for describing menu items and \u0026gt; as separator\nOpen Preferences \u0026gt; Build, Execution, Deployment \u0026gt; Debugger Use exact words as shown in UI  Выделение терминов Выделяй символом ` команды, параметры, значения, имена файлов и т.п.:\n Добавь префикс Dagger в импортах перед Component Подключи модуль dagger Введи last в поиск Добавь параметр syncAvito в файл properties.ini  Не надо выделять все названия технологий, компаний и т.п. Это нагружает текст, его труднее читать:\n Для DI используем Dagger 👎  Changing documentation How to check locally Run: docs/local.sh\nIt will open documentation at localhost:1313.\nYou can edit markdown files in the content/ on the fly. Changes out of this directory usually require a restart.\nChecklist for changes:\n Search Shortcodes: mermaid, \u0026hellip;  Hugo troubleshooting\nPublishing changes Run manually after changes: docs/publish.sh\nAuto-publish: MBS-7514.\nHow to update hugo  Обнови версию hugo в Dockerfile Обнови другие файлы  Проверь, что локально установлена такая-же версия: hugo version Сгенерируй новый сайт: hugo new site template Сравни директорию docs со сгенерированным пустым сайтом    How to update theme Скачай новую версию темы и подмени существующие файлы.\nМы кастомизировали тему, проверь что не потеряем эти изменения:\n Удалили примеры (book/exampleSite) и статику для них (book/images/) Удалили js файлы для shortcode (book/static/*.js), потому что они могут весить мегабайты. Загружаем из unpkg.com.  "});index.add({'id':26,'href':'/avito-android/docs/test/dynamicconfig/','title':"Dynamic config",'content':"Запуск тестов в CI с кастомными параметрами (internal) В Teamcity есть конфигурация instrumentationDynamic для запуска тестов со специфическим набором требований.\nЗапускайте и вам будет предложено выбрать:\n Ветку для запуска Версии API Фильтр для выбора тестов (package prefix), можно задать пакет [+ имя класса [+ имя тестового метода ]] Количество запусков. Полезно для отладки нестабильных тестов  "});index.add({'id':27,'href':'/avito-android/docs/contributing/featuretoggles/','title':"Feature toggle",'content':"Feature toggle  Feature toggle (Wikipedia) Feature toggle (Martin Fowler) Feature Toggles (Pete Hodgson)  Используется для уменьшения рисков при внедрении новой функциональности. Позволяет:\n Не держать изменения в отдельной ветке до окончания тестирования Отключить на этапе стабилизации, во время регрессионного тестирования  Cоздание Решение о создании feature toggle принимается на основе различных критериев:\n Изолированность изменений, насколько легко их отключить Риск привнести нестабильность  Реализация  По умолчанию непротестированная логика должна быть отключена Отключать необходимо самым дешевым и надежным способом, с минимальным влиянием на логику Важно не сломать существующую логику, с отключенным feature toggle, т.к. это уже нельзя отключить  Отделение точки принятия решения от логики Feature toggle - это детали реализации, подверженные изменениям. При принятии решений в логике необходимо оперировать подходящим уровнем абстракции.\nОбычно хватает выделения этих знаний в функцию.\nfun shouldUseSessionInParameters() = not(features.sessionInHeader()) Инверсия решений Чтобы убрать из логики знания про реализацию, иногда дешевле переключать всю реализацию целиком:\n@Provides CommonChannelsInteractor provideInteractor(...) { return if (features.webSocketMessengerEnabled()) { MessengerCommonChannelsInteractorImpl(...) } else { ApiCommonChannelsInteractor(...) } } Тестирование Юнит тесты Для того, чтобы выявить все непредвиденные использования переключателей, не задаем никакого состояния по умолчанию. Это вынудит в тесте явно перебрать все состояния.\n@Mock private lateinit var features: Features Компонентные и функциональные тесты В таких тестах нет возможности изоляции логики и по умолчанию используем релизное состояние переключателей. Это компромиссный вариант, в котором делаем акцент на выявлении регрессии, а не на формальной проверке всех возможных состояний. Проверка всех состояний других фич не целесообразна.\nНеобходимы, как минимум, два набора тестов:\n Проверка регресса, старого поведения. Новая фича отключена, все остальные в состоянии по умолчанию. Проверка нового поведения. Новая фича включена, все остальные в состоянии по умолчанию.  Удаление Необходимо обязательно избавляться от устаревших переключателей. Но делать это можно только после того, как убедимся в работоспособности и стабильности решения. Исходя из целей, рекомендуется удалять после feature freeze.\n"});index.add({'id':28,'href':'/avito-android/docs/git/','title':"Git",'content':"Git Слияние веток Для слияния веток используем rebase. Это дает линейную историю и снижает нагрузку на CI. Пара команд может упростить вашу жизнь с rebase: git config rerere.enabled true \u0026ndash; автоматическое разрешение повторяющихся конфликтов при rebase git config pull.rebase true \u0026ndash; rebase при обновлении remote-ветки\nLocal Git hooks ./git_hooks будут синхронизированы с .git/hooks при первом запуске gradle.\nGit LFS Могло быть полезно для хранения некоторых бинарных(или просто объемных) ресурсов в git. Например:\n изображения в документации эталоны скриншотов для тестов дизайн системы json для стабов в компонентных тестах  Не используем в проекте по ряду причин:\n нужно всем устанавливать git lfs локально, чтобы не коммитились ломающие изменения если ошибемся - переписывать историю нужно писать сервер-сайд хук, контролирующий чтобы не попадали изменения без lfs надеемся что битбакет сервер все делает правильно, а там это не прозрачно, bundled версия git и git lfs премердж наш должен учитывать lfs teamcity mirror репозиторий не работает с lfs, придется отключать похоже, а это оптимизация  "});index.add({'id':29,'href':'/avito-android/docs/contributing/howtostart/','title':"How to start",'content':"How to start Minimal requirements  16Gb RAM Linux/OSX/Windows  1. Установи Java Поддерживаем только Java 8.\n2. Установи Intellij IDEA или Android Studio Поддерживаем последнюю стабильную версию, но обычно работает и beta, и canary.\nДля обновлений рекомендуется JetBrains Toolbox.\nВ одном приложении доступны все IDE.\n3. Проверь проект  Подключи VPN Запусти в корне проекта: ./gradlew help  Должно отработать успешно. Если упадет, прочитай текст ошибки и поправь.\n3. Настрой IDE Обнови Kotlin плагин до последней версии Preferences \u0026gt; Languages \u0026amp; Frameworks \u0026gt; Kotlin\nПодключи необходимые плагины  Editorconfig - для code style  Включи оптимизации в IDE Ускорение IDE\n"});index.add({'id':30,'href':'/avito-android/docs/ide/benchmarking/','title':"IDE Benchmarking",'content':"Бенчмарки IDE Используем Performance testing plugin.\nКак попробовать?  Установи плагин Запусти Help \u0026gt; Diagnostic \u0026gt; Execute Performance Scrip from File\nВыбери готовый сценарий из /benchmarks/ide  Как проверить гипотезу и измерить разницу? Используем в ручном режиме:\n Прогони бенчмарк несколько раз до внесения изменений в проект Сохрани резульататы. Они отобразятся в диалоге после прогона бенчмарка Внеси изменения в проект Прогони бенчмарк несколько раз, сравни результаты.  Что еще?  Плагин умеет записывать YourKit snapshot с детальной информацией о всех вызовах методов.  "});index.add({'id':31,'href':'/avito-android/docs/ide/configurations/','title':"IDE Custom configurations",'content':"Кастомные конфигурации Шарим в проекте кастомные run/debug конфигурации, чтобы все работало \u0026ldquo;из коробки\u0026rdquo;.\nТак гарантируем одинаковые корректные настройки, случайно не сломается.\n  avito: собирает, устанавливает и запускает Авито.\n  avitoInstall: собирает и устанавливает Авито, но не запускает автоматически приложение.\nНужна из-за бага \u0026ldquo;Default activity not found\u0026rdquo;.\n  localCheck: проверка всех этапов компиляции с учетом импакт анализа\n  Как расшарить конфигурацию? Sharing Run/Debug Configurations\n"});index.add({'id':32,'href':'/avito-android/docs/ide/speedup/','title':"IDE Speedup",'content':"Ускорение IDE Чтобы IDE меньше тормозила при работе с проектом, попробуй эти настройки:\nВыдай IDE больше памяти По умолчанию IDE выделяет мало, чтобы суметь запуститься на слабой машине.\nHelp \u0026gt; Edit custom VM Options\n-Xmx4g Слишком много не нужно. Чтобы посмотреть реальное потребление памяти:\nAppearance \u0026amp; Behavior \u0026gt; Appearance \u0026gt; Show memory indicator\nВключи удаленную сборку Mirakle\nОставь только необходимые приложения Подключаем в settings.gradle только часть приложений, чтобы ускорить работу с проектом. Посмотри в gradle.properties флаги sync... и выбери какие нужны.\nПереопределяй в системных настройках (~/.gradle/gradle.properties):\nsyncAvito=false sync... После изменения синхронизируй проект.\nОтключи излишние действия во время синхронизации  Preferences \u0026gt; Experimental \u0026gt; Skip source generation on Gradle sync Preferences \u0026gt; Experimental \u0026gt; Skip download of sources and javadoc on Gradle sync Preferences \u0026gt; Build, Execution, Deployment \u0026gt; Compiler \u0026gt; Sync project with Gradle before building  Проверь что Gradle и Kotlin не запускают несколько демонов ./gradlew --status Если запущено несколько: https://stackoverflow.com/c/avito/questions/109\nОтключи неиспользуемые плагины  Android APK Support Android Games Android NDK App Links Assistant CVS, hg4idea, Subversion integration Firebase  GitHub Google  Task management Terminal Test recorder, TestNG YAML  Отключи индексацию директорий (Spotlight, Антивирус) При сборке проект генерирует много файлов, что вызывает постоянную переиндексацию.\nOSX\nДобавь в исключения Spotlight: System preferences \u0026gt; Spotlight \u0026gt; Privacy\n Директории с android проектами (обязательно) Android SDK Android Studio ~/.gradle ~/.android ~/.gradle-profiler ~/gradle-profiler ~/.m2 ~/Android StudioX.X ? ~/lldb ?  tip: показать скрытые директории в Finder: Cmd + Shift + .\nСкрой ненужные директории и типы файлов Проект большой и в нем много сгенерированных файлов, что нагружает IDE. Чтобы немного помочь, скрой файлы, которые никогда не нужны:\nPreferences \u0026gt; Editor \u0026gt; File Types \u0026gt; Ignore Files and Folders\nНедостатки:\nПро эти исключения легко забыть, неочевидно, может помешать:\n build - не будут видны BuildConfig файлы, сгенерированные файлы, вообще ничего. .gradle;intermediates;kotlin-classes;caches-jvm; - intermediates файлы сборки, обычно не нужны. apt;kapt;kaptKotlin; не будут видны Dagger файлы.\nОни будут красными в редакторе и автоформатирование может удалять их импорты.  kotlin.use.ultra.light.classes (experimental) A light class is a representation of a Kotlin class as the Java PSI, allowing IntelliJ IDEA\u0026rsquo;s Java support features to work with Kotlin classes.\nCmd + Shift + A - найди Registry, включи флаг kotlin.use.ultra.light.classes.\nОсвободи в ОС больше памяти Посмотри какие приложения потребляют много памяти, не используется ли swap.\nДля Google Chrome есть плагины для авто-остановки старых вкладок: The Great suspender\nВключи режим энергосбережения Отключает инспекции и подсветку синтаксиса\nFile \u0026gt; Power Save Mode\n"});index.add({'id':33,'href':'/avito-android/docs/infrastructure/','title':"Infrastructure project",'content':"Avito android infrastructure on github Monorepo of all tooling to continuously test and deliver apps to users\nModules Gradle plugins To use plugins in your project:\nbuild.gradle\nbuildscript { dependencies { classpath(\u0026#34;com.avito.android:instrumentation-tests:$avitoToolsVersion\u0026#34;) } repositories { jcenter() } } apply(\u0026#34;com.avito.android.instrumentation-tests\u0026#34;) or\nbuild.gradle\nplugins { id(\u0026#34;com.avito.android.instrumentation-tests\u0026#34;) } and in settings.gradle\npluginManagement { repositories { jcenter() } resolutionStrategy { eachPlugin { String pluginId = requested.id.id if (pluginId.startsWith(\u0026#34;com.avito.android\u0026#34;)) { def artifact = pluginId.replace(\u0026#34;com.avito.android.\u0026#34;, \u0026#34;\u0026#34;) useModule(\u0026#34;com.avito.android:$artifact:$avitoToolsVersion\u0026#34;) } } } }  :artifactory-app-backup - Gradle plugin to back up build artifacts in artifactory :build-metrics - Gradle plugin for gathering build metrics and deliver it to grafana :build-properties - Gradle plugin to deliver custom build parameters to android assets :buildchecks - Gradle plugin to early detection of build problems :cd :dependencies-lint - Gradle plugin to detect unused Gradle dependencies :design-screenshots - Gradle plugin, extended tasks to support screenshot testing on top of our :instrumentation plugin :docs - Gradle plugin to automate documentation deployment (was used to deploy internally //todo remove) :enforce-repos - Gradle plugin to configure dependencies repositories for internal project :feature-toggles - Gradle plugin to extract feature toggles values from code and report it as build artifact :impact, :impact-shared - Gradle plugin to search parts of the project we can avoid testing based on diff. :instrumentation-tests - Gradle plugin to set up and run instrumentation tests on android :instrumentation-test-impact-analysis, :ui-test-bytecode-analyser - Gradle plugin to search ui tests we can avoid based on impact-plugin analysis :kotlin-root - Gradle plugin to configure kotlin tasks for internal project :lint-report - Gradle plugin merging lint reports from different modules :module-types - Gradle plugin to prevent modules go to wrong configurations (android-test module as an app\u0026rsquo;s implementation dependency for example) :code-ownership - Gradle plugin to prevent dependency on other team\u0026rsquo;s private modules :performance - Gradle plugin, extended tasks to support performance testing on top of our :instrumentation plugin :prosector - Gradle plugin and client for security service :qapps - Gradle plugin to deliver apps to internal distribution service, see QApps :robolectric- Gradle plugin to configure robolectrtic for internal project :room-config - Gradle plugin to configure room for internal project :signer - Gradle plugin for internal app signer  Buildscript dependencies  :android - android Gradle plugin extensions, and android sdk wrapper // todo separate :bitbucket - bitbucket server client to deliver checks results right into pull request context via code insights and comments :docker - docker client to work with docker daemon from gradle :files - utils to work with files and directories :git - git client to work within gradle See impact analysis :kotlin-dsl-support - Gradle api extensions //todo rename :kubernetes - kubernetes credentials config extension :logging - custom logger to serialize for Gradle workers //todo no longer a problem, remove :pre-build - extensions to add tasks to the early stages of build :process - utils to execute external commands from gradle :runner:client, :runner:service, :runner:shared, :runner:shared-test - instrumentation tests runner :sentry-config - sentry client config extension :slack - slack client to work within Gradle plugins :statsd-config - statsd client config extension :teamcity - wrapper for teamcity client and service messages :test-project - Gradle Test Kit project generator and utilities :test-summary - test suite summary writer :trace-event - client for trace event format :upload-cd-build-result - client for internal \u0026ldquo;Apps release dashboard\u0026rdquo; service :upload-to-googleplay - wrapper for google publishing api :utils - //todo remove  Android-test modules Code that goes in androidTestImplementation configuration and runs on emulators.\n :junit-utils - //todo move to common :mockito-utils - //todo move to common :resource-manager-exceptions - //todo remove :test-annotations - annotations to supply meta information for reports and test management system :test-app - app we are using to test :ui-testing- libraries :test-inhouse-runner - custom android junit runner :test-report - client to gather test runtime information for reporting :ui-testing-core - main ui testing library, based on espresso :ui-testing-maps - addon for main library to test google maps scenarios :websocket-reporter - client to gather websocket info for reporting  Common modules Shared modules between android-test and gradle.\n :file-storage - client for internal file storage client, used to store screenshots, videos and other binary stuff :okhttp - okhttp extensions :sentry - sentry client :statsd - statsd client :test-okhttp - wrapper for okhttpmockwebserver :time - simple time api  Publishing Versioning projectVersion is version for future release.\nRelease to jcenter Bintray project, mirroring to jcenter\n Checkout branch with name equally to projectVersion Make sure integration tests on release branch passed via CI integration tests against avito Manually run Teamcity configuration (internal) Use new version in avito Create PR with infraVersion equally released version and bumped projectVersion Create release on releases page  Local integration tests against avito  Choose project version that will not clash with released ones (example: 2020.2.4-\u0026lt;yourname\u0026gt;-1) Run ./gradlew publishToMavenLocal -PprojectVersion=\u0026lt;Your test version\u0026gt; Run integration tests of your choice in avito with specified test version  CI integration tests against avito  Run Teamcity configuration (internal) to check pull request builds. And/or This one to check full set of checks. You don\u0026rsquo;t need to be bothered about versions here, checks of avito would run against generated version of tools project.  You can also change build branch if you need to test unmerged code. But be careful, Teamcity is tricky about this one:\n By default build will use develop from github agains develop from avito If you pick a different branch of avito, it will run against develop on github If you pick a different branch of github, it will run against develop on avito (UNTESTED) To build both projects of special branch, they should have the same name   "});index.add({'id':34,'href':'/avito-android/docs/test_framework/internals/','title':"Internals",'content':"Internals Custom click It is a click without inter-process communication.\nMotivation to write custom click Espresso click uses inter-process communication. It leads to problems:\n Flaky clicks on moving views. Because click takes some time to touch after coordinates calculating. \u0026ldquo;misinterpret clicks as long clicks\u0026rdquo;  Implementation details Click happens via dispatch touch event on root view.\nKnown issues  Can click through any system elements on the screen. It applies clicks directly on root view of our application. Because of it, crash or permission dialogs can be ignored by tests. Can click through separate decor view of our application. Sometimes we have multiple decor view in application (for example, when we have toolbar overflow menu). And that kind of click implementation can click through it. Overlapped view can\u0026rsquo;t handle click. We can\u0026rsquo;t realize when view is overlapped. Because of that clicks on overlapped views don\u0026rsquo;t work and don\u0026rsquo;t throw errors.  Overlapped view click details We tried to validate that click happens.\nWe were able to check that clicked view wasn\u0026rsquo;t overlapped, but faced scenario when user clicked on container and expected it to delegate click handling to child. We don\u0026rsquo;t want to restrict our user, because many tests behave like that.\n"});index.add({'id':35,'href':'/avito-android/docs/knownissues/','title':"Known Issues",'content':"Known Issues New Gradle Sync is not supported due to containing Kotlin modules Disable Settings \u0026gt; Experimental \u0026gt; Only sync the active variant\nhttps://stackoverflow.com/questions/54201216/android-studio-3-3-new-gradle-sync-is-not-supported-due-to-containing-kotlin-mo/\n"});index.add({'id':36,'href':'/avito-android/docs/test/manual/','title':"Manual",'content':"Ручное тестирование Обрати внимание на Типы Сборок\nГде взять сборку? QApps\n"});index.add({'id':37,'href':'/avito-android/docs/assemble/minimization/','title':"Minimization",'content':"Минимизация сборки Официальная документация\nВ проекте используется R8 (задача (internal) на включение \u0026ldquo;full mode\u0026rdquo;)\nПараметры для сборки задаются в корневом gradle.properties\nВ каких типах сборки включена минимизация: Типы сборки\nStory \u0026ldquo;Защита от ошибок минификации кода\u0026rdquo; (internal)\nКонфигурация Общая конфигурация собирается по частям из нескольких источников. Помимо способов описанных в документации, конкретно в нашем проекте используется:\n $ANDROID_HOME/tools/proguard/proguard-android-optimize.txt базовый конфиг \u0026lt;app\u0026gt;/proguard/**/*.pro конфигурации разбитые по папкам-типам-сборки, а затем отдельным файлам зависимостям. Собираются в build.gradle при помощи своей функции proguardFromDir()  Посмотреть результирующий конфиг сейчас негде, есть задача (internal) на добавление его в артефакты\nТестирование Как запустить автотесты на сборке с минимизацией\nМатериалы по теме  Как перестать бояться Proguard и начать жить Неофициальная документация  "});index.add({'id':38,'href':'/avito-android/docs/assemble/mirakle/','title':"Mirakle",'content':"Mirakle Это Gradle плагин, который переносит сборку проекта на более мощную машину в дата центре. Компьютер во время сборки не так нагружен, можно продолжать работать с проектом.\nКак работает:\n sequenceDiagram 💻-+Builder: Держи проект (rsync) Note right of Builder: Собираю Builder--💻: Получи что уже готово Builder--💻: Закончил Как настроить в первый раз?  Установи rsync Посмотри какой host прописан в mirakle.py Проверь доступность удаленной машины по ssh (с VPN):\nssh [\u0026lt;username\u0026gt;@]\u0026lt;mirakle host\u0026gt;\nЕсли нет доступа:  Проверь есть ли уже ключ (checking for existing SSH keys) или сгенерируй новый. Нужен ключ без пароля, потому что из mirakle (Gradle) его некуда вводить. Добавь свой публичный ssh ключ - инструкция (internal) Запроси в Service Desk (internal) доступ по ssh на host android-builder   Включи mirakle: ./mirakle.py --enable\nЕсли локальный пользователь отличается: ./mirakle.py --enable --username \u0026lt;username\u0026gt; Проверь работу, запусти любую задачу: ./gradlew help\nВ логе будут сообщения:  Here's Mirakle ... :uploadToRemote :executeOnRemote :downloadInParallel  Проверь кастомные системные параметры сборки в ~/.gradle/gradle.properties\nОни не переносятся на удаленную машину. Выбираем один из вариантов:  Добавь в аналогичный файл на android-builder Добавь аргументами -Pname=value в Preferences \u0026gt; Build, Execution, Deployment \u0026gt; Compiler \u0026gt; Command-line Options\nNB: про такие настройки легко забыть, по возможности избегай их.    В следующие разы нужно только включать ./mirakle.py --enable\nКак отключить? ./mirakle.py --disable\nЧтобы отключить только для текущей сборки, добавь в аргументы Gradle -x mirakle\nПолное удаление настроек: /mirakle.py --wipe\nTroubleshooting  Проверь что vpn подключен Проверь доступность mirakle, подключись по ssh  Known issues Сборка в mirakle идет дольше чем локальная  Копирование проекта на другую машину занимает время. Если собираешь что-то небольшое, то сравни с локальной сборкой. Она может оказаться быстрее. На удаленной машине накопились старые файлы в проекте, rsync их не удалил.\nУдали их: ./clean.py --remote  Запустилось не то, что я запускал Проверь что синхронизация проекта проходит успешно.\n"});index.add({'id':39,'href':'/avito-android/docs/test_framework/mocking/','title':"Mocking in tests",'content':"Mocking in tests Mocks (internal) Mocking network TBD\nMocking analytics There are different options:\n MockAnalyticsRule: mocks analytics completely AnalyticsRule: only intercepts events and tries to not interfere with real implementation \u0026lt;test without rule\u0026gt;: real implementation  @get:Rule val analytics = AnalyticsRule() analytics.checks.assertEventTracked\u0026lt;ShowSearchEvent\u0026gt;() Mocking location LocationRule serves for mocking location in tests.\n@get:Rule val locationRule = LocationRule() locationRule.setLocation(getTestLocation()) KEEP IN MIND that above rule does not mock location for the whole device but rather replace the best known location in BaseGeoProvider. That is technically possible that device location providers would give better location that was mocked. To avoid that mock location with high accuracy.\nMocking User-Agent It is possible to mock User-Agent for test suite or for specific test with @UserAgent annotation. Here\u0026rsquo;s an example:\n@UserAgent(\u0026#34;AVITO 59.0 (Android 8.1.0; ru)\u0026#34;) class MyAwesomeTests {} This annotation is available in all types of tests but make sense mostly for functional tests.\nWriting custom mocks for tests Different tests need different mocks. We have to adapt an application state for these requirements.\nWe can define different types of tests:\n With mocked network With real network With mocked analytics \u0026hellip;  Trouble is, it leads to a combinatorial explosion.\nWe want to be sure that our changes in mocks for one test won\u0026rsquo;t break other tests. Therefore, it is better to have a straightforward and explicit relationship between a test and an application state.\nHow do we adapt an application state exclusively for one test?\n Test Runner starts before the application.\nSee InHouseInstrumentationTestRunner. Test Runner finds a test for running in arguments.\nIt parses test class (annotations, methods, rules) and saves this information into a Bundle.\nSee TestMetadataInjector The Test App reads parameters from InstrumentationRegistry.getArguments().\nNow we know requirements for the exact test and configure an application state with minimum side effects. The test is starting, and the application is already in the desired state.  "});index.add({'id':40,'href':'/avito-android/docs/architecture/modules/','title':"Modules",'content':"TBD: http://links.k.avito.ru/cfxFKKAg (internal)\n"});index.add({'id':41,'href':'/avito-android/docs/assemble/profiling/','title':"Profiling",'content':"Профилирование сборки Чтобы посмотреть подробную информацию о скорости сборке попробуй разные инструменты, выбери наиболее простой.\nBuild Speed window (AS 4+)  Собери проект View \u0026gt; Tool Windows \u0026gt; Build \u0026gt; Build Speed  Gradle build scan https://guides.gradle.org/creating-build-scans/\nЗапусти сборку с аргументом --scan.\nВ конце лога будет ссылка на отчет.\nKnown issues:\n Не приходит первое письмо для активации ссылки:\nнапиши в help@gradle.com, приложи ссылку. This build scan cannot be viewed. A permanent error occurred processing the data.\nСкорее всего уперлись в лимит на размер скана. Нет способа проверить это заранее.\nПопробуй собрать что-то более мелкое. Завышено время исполнения задач (#8630)\nЭто видно по косвенным признакам. На графике задача завершается сразу после завершения другой задачи из этого же модуля.  Avito build trace Чтобы обойти ограничения build scan, собираем свой trace со временем исполнения задач.\nВ CI сборках лежит в артефактах TeamCity.\nКак использовать:\n Запусти сборку с любым из аргументов:\n-Pci=true, --scan, --profile, -Pandroid.enableProfileJson=true. Открой файл outputs/trace/build.trace в chrome://tracing  Known issues:\n Завышено время исполнения задач (см. выше).  Реализация:\nСмотри плагин com.avito.android.build-metrics.\nGradle profiler В режиме профилировщика умеет запускать внешние профилировщики.\nПопробуй разные, тут нет однозначного победителя.\ngradle-profiler --profile async-profiler \\ --project-dir . \\ --warmups 1 \\ --gradle-user-home ~/.gradle-profiler \\ --output-dir profiler \\ help Android Tracer mirror-goog-studio-master-dev/tracer/\nЛегкий профилировщик от Google:\n Показывает исполнение кода из AGP внутри Gradle worker Можно разметить аннотациями свой код или указать в конфиге, что логировать  Как использовать:\n Запусти сборку с параметром android.enableProfileJson=true Открой файл build/android-profile в chrome://tracing  Кастомная конфигурация:\n Прочти README, есть неочевидные вещи. (jar файл нельзя переименовывать и т.п.) Выбери профиль, в репозитории есть пара под разные сценарии. Прокинь агент в демон, подходит GRADLE_OPTS:\nexport GRADLE_OPTS=\u0026quot;-javaagent:/path/to/trace_agent.jar=/path/to/deploy.profile\u0026quot; Добавь в jvm args в gradle.properties:\norg.gradle.jvmargs=\u0026quot;-javaagent:/path/to/trace_agent.jar=/path/to/deploy.profile\u0026quot;  Полезно посмотреть в образовательных целях, как пример профилирования с помощью java agent\n"});index.add({'id':42,'href':'/avito-android/docs/cd/qapps/','title':"QApps",'content':"QApps (internal) QApps Android\nВнутреннее хранилище сборок для ручного тестирования.\nЗаливаем в него apk по расписанию из develop.\nСм. конфиг uploadToQapps в build.gradle приложений.\nКак залить вручную в QApps с ветки? Локально  Для каждого приложения есть задача qappsUpload\u0026lt;build variant\u0026gt;.\nОна заливает уже собранную apk.\n Собери apk ./gradlew :avito:qappsUploadStaging -Pci=true\nЧтобы было проще найти сборку, укажи комментарий аргументом -PbuildNumber=\u0026quot;my custom build\u0026quot;  Known issues  Для релизной сборки не совсем подходит, т.к. не будет подписана релизным сертификатом. Чтобы отправить с другими versionName, versionCode нужно собрать приложение с этими параметрами.\nДля qapps это только комментарии к бинарнику. Даже если обмануть и залить apk в qapps указав другую версию, содержимое apk от этого не изменится.   Из CI  Запусти конфигурацию fullCheck\nВыбери кастомный запуск, укажи свою ветку.\nKnown issues Длится до 1 часа, запускает все тесты.\nЧтобы ускорить, закомментируй лишние шаги в fullCheck конфиге в build.gradle приложений.\nЗадача на более быстрый способ: MBS-7340\n  "});index.add({'id':43,'href':'/avito-android/docs/cd/release/','title':"Release",'content':"Релиз приложения Android (internal) Канал для коммуникации: #regression-android\nDashboard релизов\nПолитика релизов мобильных приложений\nКак сделать фикс Для каждого релиза отводим ветку release/\u0026lt;Номер версии\u0026gt;\n Отводим ветку от релизной Делаем ПР с фиксом в релизную ветку Создаем ветку от текущего develop Делаем ПР с черри-пиком того же коммита в develop  Кто сейчас релиз менеджер? На dashboard'е конкретного релиза есть поле Release manager\n"});index.add({'id':44,'href':'/avito-android/docs/test/reportviewer/','title':"Report Viewer",'content':"Report Viewer (internal) Используем отчеты в Report Viewer (internal), которые содержат:\n Видео с эмулятора  Только для упавших тестов Только для API 23+. На меньших версиях технологии не позволяют записывать надежно   Скриншоты: до и после каждого шага, во время падения Трейс ошибки: цепочка событий которая привела к ошибке Logcat для упавших тестов HTTP запросы и ответы во время шагов Логи запросов к ресурсам: Resource Manager, AB/test, Integration API, phones Логи действий тестового фреймворка  Using report viewer in a local run Report Viewer works in local runs too.\nSearch a link in a logcat by rv.k.\n"});index.add({'id':45,'href':'/avito-android/docs/analytics/statsd/','title':"Statsd",'content':"Statsd (Graphite) Realtime-метрики для отслеживания текущего состояния.\nMonitoring (internal) - см. презентацию в самом начале.\nСм. использование StatsdEvent.\n"});index.add({'id':46,'href':'/avito-android/docs/tech_radar/techradar/','title':"Technology radar",'content':"Technology radar Technology radar is a list of technologies and practices that are described in the same manner:\n An overall status and recommendations for usage Limitations Reasons for choosing or declining  Original: https://www.thoughtworks.com/radar\nThe radar  Gradle - buildSrc  Template\nFAQ Detailed FAQ\nWhat questions does tech radar help to solve?  What criteria is technology selected or declined by? What should happen to reconsider the choice? I want to use X. How can I compare it against Y?  Do I have to use tech radar for all technologies? The harder to replace a technology, the more pragmatic we want to be.\nIt\u0026rsquo;s needless for something that can be replaced in a week or two.\nIs it mandatory or only recommendations? Tech radar helps to avoid a tragedy of the commons.\nWe all may have different opinions but we are in the same boat.\nTech radar can\u0026rsquo;t solve any conflict by itself. It only helps to share our knowledge and decisions.\nIn order to mitigate risks it has different statuses with different requirements.\nWhy don\u0026rsquo;t we use Avito\u0026rsquo;s tech radar? Stand-alone tech radar makes sense when you have dozens of services and repositories with the same common technologies.\nIn our case, such tech radar tends to become outdated. It\u0026rsquo;s easier to track changes and keep it up to date together with a product.\n"});index.add({'id':47,'href':'/avito-android/docs/tech_radar/template/','title':"Technology radar Template",'content':"The Name Quadrant: tools|techniques|platforms|languages \u0026amp; frameworks\nStatus (ring): hold|assess|trial|adopt\nThe description.\nFAQ\n"});index.add({'id':48,'href':'/avito-android/docs/test_framework/testframework/','title':"Test framework",'content':"Test framework ViewElement PageObject над View. Составляющие:\n InteractionContext - знания про родительский элемент, окружение Actions - действия с элементом Checks - проверки состояния  Создание Для создания используем фабричную функцию element:\nval submitButton: ViewElement = element(withId(R.id.submit_button)) ViewMatcher будет учитывать родительский PageObject, унаследует его matcher.\nВложенные ViewElement Все PageObject могут быть вложенными, отражать реальную иерархию:\n// parent -\u0026gt; container -\u0026gt; button  val container: ViewElement = element(withId(R.id.container)) val button: ViewElement = container.element(withId(R.id.button)) Кастомный ViewElement Для переиспользования Бывает удобно отразить вложенность отдельным классом, чтобы переиспользовать в разных экранах.\n// parent --\u0026gt; selector --\u0026gt; hint  val selector: ImageSelectorElement = element(withId(R.id.selector)) class ImageSelectorElement(interactionContext: InteractionContext) : ViewElement(interactionContext) { val hint: ViewElement = element(withId(R.id.hint)) } Для кастомных actions, checks Еще одна причина для кастомного ViewElement - переопределить кастомные actions, checks. Примеры: RatingBarElement, BottomSheetElement.\nДля дефолтного Matcher Для переиспользуемых компонентов удобно держать внутри знания про дефолтный матчер.\nПри создании элемента будем только дополнять его, но не заменять.\nПока что не умеем модифицировать уже созданный interaction context, поэтому перехватываем при создании элемента:\nclass ElementWithEmbeddedMatcher : HandleParentContext, ViewElement { constructor(interactionContext: InteractionContext) : super(interactionContext.provideChildContext(defaultMatcher())) constructor(interactionContext: InteractionContext, matcher: Matcher\u0026lt;View\u0026gt;) : super(interactionContext.provideChildContext(Matchers.allOf( defaultMatcher(), matcher ))) } HandleParentContext - маркерный интерфейс. Изменяет поведение функции PageObject.element(matcher). Мы сами создаем дочерний контекст, потому что только мы знаем про дефолтный матчер.\nScreen Это PageObject для экрана (activity, fragment, dialog, \u0026hellip;)\nclass PublicProfileScreen : PageObject(), Screen { ... } rootId Явно связываем PageObject с конкретным layout:\noverride val rootId: Int = com.avito.android.public_profile_stuff.R.id.public_profile_screen_root  Помогает быстрее найти какой PageObject для этого экрана и в обратную сторону Все дочерние элементы в PageObject неявно проверяем на вхождение в этот layout Связывает экран с gradle-модулем. Это нужно для работы импакт-анализа  Элементы PageObject содержит вложенные элементы:\nval submitButton: ViewElement = element(withId(R.id.submit_button)) Используем фабричный метод element, чтобы создать вложенный элемент. При каждом действии или проверке автоматически проверяем какой экран сейчас отображается.\nScreenChecks Каждый экран умеет проверять, открыт он сейчас или нет.\nПроверить можно вручную:\nassertion(\u0026#34;\u0026#34;\u0026#34;Перешли на экран ...\u0026#34;\u0026#34;\u0026#34;) { Screen.vasPublish.checks.isOpened() } Недостатки очевидны:\n Добавляем проверки вручную, зачастую уже после того как столкнемся с ошибкой Проверки надо поддерживать Это шум. Если я обращаюсь к элементу экрана, то ожидаю что экран должен быть сейчас виден.  Мы умеем автоматически проверять какой экран открыт перед любым действием или проверкой.\nДля этого необходимо подготовить экран:\n Проверить что экран наследуется от PageObject Проверить что экран использует автоматическую проверку  override val checks: ScreenChecks = StrictScreenChecks(this) Включим это по умолчанию в MBS-7204 (internal)\n Создавать вложенные элементы с помощью фабричной функции element:  val submitButton: ViewElement = element(withId(R.id.submit_button)) // 👍 val submitButton = ViewElement(withId(R.id.submit_button)) // 👎 Legacy Так мы связываем вложенный элемент с экраном и используем это уже во всех его действиях:\nsubmitButton.checks.displayedWithText(\u0026#34;Отправить\u0026#34;) // \u0026lt;-- здесь неявно проверим что текущий экран открыт Параметризация экрана Часто бывает что один и тот-же экран умеет показывать разные данные, загруженные из API.\nУдобно знать про эти состояния и учитывать в проверках:\nfun Screen.publishParamsWithTitle(title: String) = PublishParamsScreen(title) class PublishParamsScreen(val title: String? = null) : PageObject(), Screen { ... if (title != null) { title.checks.withText(title) } ... } "});index.add({'id':49,'href':'/avito-android/docs/test/testmanagementsystem/','title':"Test Management System",'content':"Test Management System (internal) В Авито используется собственная TMS, которой нет в open-source.\nВнутренняя документация\nМетаданные @FeatureId(IntArray) - указать принадлежность к глобальному дереву фич приложения @TagId(IntArray) - принадлежность к облаку тегов теста (у каждой команды свое)\n\u0026ndash; deprecated \u0026ndash;\n@CaseId(Int) - id теста в TMS, не актуально после введения test case in code @Features(vararg String) - строковое представление фич, не используется в синхронизации\nKind Для того чтобы визуализировать тестовую пирамиду, указывается тип см. com.avito.report.model.Kind\nTest case in code Правда о тест кейсе исторически хранилась в TMS.\nПоддерживать актуальной информацию сразу в двух местах не самое достойное занятие, а увеличение кол-ва автоматизированных кейсов остро поставило вопрос о стоимости этого занятия.\nЧтобы упростить поддержку, появилась возможность держать источник правды в коде, синхронизируя всю информацию в TMS.\nКак синхронизировать свой тест с TMS? Чтобы это сделать, тесту нужно проставить аннотацию @ExternalId(UUID), где UUID - сгенерированный на клиенте случайный UUID.\nС возможными коллизиями пока никак не боремся  FAQ Q: Когда происходит синхронизация A: После попадания кода в ветку develop\nQ: Как выглядит такие тесты в TMS A: Становятся read-only\nStubs: tests without implementation Если тестами хочется управлять из кода уже сейчас, а их написание отложить, то можно просто создать стабы.\nСтабы это тесты со всей нужной информацией (аннотации, шаги), но не выполняющие никаких действий и проверок.\nЧтобы на уровне TMS отличать автоматизированные тесты, от стабов, добавлены специальные типы с приставкой -stub (см. com.avito.report.model.Kind)\nТип manual - специально для указания ручных тестов, которые не планируется автоматизировать, но хочется держать рядом с автотестами в коде.\nStubs generation  TODO вынести в opensource для демонстрации\n Для упрощения переноса в проекте есть модуль :test-generator, который по указанию списка id тесткейсов генерирует код тестов-стабов.\n"});index.add({'id':50,'href':'/avito-android/docs/test/testminimized/','title':"Test minimized build",'content':"Testing minimized build About minimization: link\nWe want to run our ui tests against build as close as possible to production one.\nIt\u0026rsquo;s quite a challenging task, mostly because of tooling problems\nDevelopers should maintain a list of keep rules of code referenced from test app manually.\nWe work around these problems by using keeper.\nBuild type Our build types: link\nAndroid Gradle plugin uses testBuildType property to determine which build type to test.\nWe chose stagingAutoTest as a type to test against in CI environment.\nHowever local builds defaults to debug type for faster test writing cycle.\nDeveloper who wants to reproduce test problem specific to CI locally, should temporary change \u0026lt;appname\u0026gt;.testBuildType property to stagingAutoTest in ~/.gradle/gradle.properties.\nSample You can check configuration in :test-app module.\nKnown issues Dynamically referenced resources You can see in PageObjectTest, that we referenced R.layout.page_object_1, dynamically creating layout.\nThese layouts referenced nowhere in app code, so if shrinkResources enabled you will face strange error:\nerror inflating class x Caused by: java.lang.ClassNotFoundException: Didn\u0026#39;t find class \u0026#34;android.view.x\u0026#34; on path: DexPathList What it really hides, R.layout.page_object_1 got shrinked to:\n\u0026lt;x /\u0026gt; If this is your case, add these resources to res/raw/keep.xml like this:\n\u0026lt;resources xmlns:tools=\u0026#34;http://schemas.android.com/tools\u0026#34; tools:keep=\u0026#34;@layout/page_object*\u0026#34;/\u0026gt; X already has a mapping Issue #122924648 - Solved in a 1.6.x\nSome issues could be solved in a new version of r8, you should consider upgrading before hacking further.\nBy default, r8 bundled with android Gradle plugin, but you can override it.\nbuildscript { val r8Version: String by project repositories { maven { setUrl(\u0026#34;http://storage.googleapis.com/r8-releases/raw\u0026#34;) } } dependencies { classpath(\u0026#34;com.android.tools:r8:$r8Version\u0026#34;) // \u0026lt; it should be added before android Gradle plugin  } } For versions check tags here: https://r8.googlesource.com/r8/\nSeems like 1.5 versions bundled with agp 3.5.x\n1.6 -\u0026gt; 3.6.x\nand 2.0 -\u0026gt; 4.0.x\n Don\u0026rsquo;t forget to tell keeper, you are using different r8 version:\ndependencies { keeperR8(\u0026#34;com.android.tools:r8:$r8Version\u0026#34;) }   Still NoSuchMethodError Take a look at module :subprojects:android-test:keep-for-testing for additional keep annotations.\nIt\u0026rsquo;s a workaround described here: Issue #143419092\nYou still need to add proguard rules as pointed in annotation classes comments.\n Why not package proguard rules?\n In this case rules goes into all variants, and you only want tested one.\n Why not use original @Keep?\n Just to distinguish an intent, it\u0026rsquo;s for testing and only in tested variant\n"});index.add({'id':51,'href':'/avito-android/docs/assemble/troubleshooting/','title':"Troubleshooting",'content':"Troubleshooting Что делать в случае непонятной ошибки? Ситуация: падает синхронизация проекта или сборка. По ошибке ничего не понятно.\nЧтобы найти причину, проще всего последовательно исключать все возможные.\n Исключи влияние локальных изменений: проверь на свежем develop Проверь что включен VPN Исключи mirakle: ./mirakle.py -d Исключи IDE: проверь из консоли Проверь не переопределено ли что-то подозрительное в ~/.gradle/gradle.properties Убедись что конфигурация проекта проходит успешно: ./gradlew help Посмотри детальную ошибку: `./gradlew \u0026ndash;stacktrace Исключи влияние кеширования: ./gradlew \u0026lt;failed task\u0026gt; --no-build-cache\nОчистить кеш можно командой: ./gradlew cleanBuildCache  Если проблема в IDE В консоли отработало без ошибок, но в IDE падает.\n Проверь версию IDE и Kotlin плагина. Возможно они слишком старые или наоборот, alpha/beta версии. Добавь --stacktrace чтобы увидеть детали ошибки:\nSettings \u0026gt; Build, Execution, Deployment \u0026gt; Compiler \u0026gt; Command-line Options:_ Проверь что не включен offline mode на вкладке Gradle Возможно ошибка в .iml, .idea/ файлах:  ./clean.py --all или File \u0026gt; Re-Import Gradle project File \u0026gt; Invalidate Caches / Restart   Посмотри логи Help \u0026gt; Show log in Finder  Если причина в Mirakle Возможно из mirakle прилетают некорректные данные. Удали их: ./clean.py -r\nКак искать проблемы с кешированием? TBD\nKnown issues D8: Dex file with version \u0026lsquo;N\u0026rsquo; cannot be used with min sdk level \u0026lsquo;M\u0026rsquo; Dex file with version '38' cannot be used with min sdk level '22'. D8 com.android.builder.dexing.DexArchiveMergerException: Error while merging dex archives Предположительно возникает после изменений в плагинах.\nПомогает ./clean.py -a\n"});index.add({'id':52,'href':'/avito-android/docs/test/troubleshootingui/','title':"Troubleshooting UI Tests",'content':"Troubleshooting Known issues All known bugs: jira filter (internal)\nCamera auto-focus hangs up on 22 API #139438163\nThere is no workaround. Skip test on this API level.\nError in local run: \u0026ldquo;Test framework quit unexpectedly\u0026rdquo; Usually it indicates a problem in test runner, see logcat for errors.\nIn some cases test can run without problems. Use a local test report\nКак понять почему упал тест? Посмотри в TeamCity, в тесте краткая выжимка о причинах падения и ссылка на отчет в Report Viewer\nHow to deal with flaky test 1. Убедись что тест действительно флакует Посмотри статистику стабильности теста\nДля проверки запускай тест в несколько прогонов в динамической конфигурации.\n2. Отлаживай в IDE В Android Studio должен из коробки работать debug на конкретном тесте.\nhttps://developer.android.com/studio/debug\nLayout Inspector Layout inspector использует adb поэтому мы не можем получить состояние экрана в дебажном запуске.\nКак получить экран во время прогона теста?\n Добавить в нужное место Thread.sleep(). Запустить тест без дебага и дождаться пока исполнение попадет в Thread.sleep() Задампить состояние экрана через Layout Inspector  3. Если не удалось найти причину Обратись за помощью\nПриложи сылку на репорт.\nПомогут также логи с ошибками.\nГде посмотреть статистику по стабильности тестов?  Общая статистика по тестам (internal) История нестабильности теста (internal)  Обратите внимание на параметры фильтрации.\n"});index.add({'id':53,'href':'/avito-android/docs/test/unittesting/','title':"Unit tests",'content':"Unit tests How to write good tests (mockito)\nAssertions Рекомендуется использовать assertThat() вместо assertEquals() и т.п.\nМотивация Типизация assertEquals(\u0026quot;id\u0026quot;, 1L) - падает только в рантайме assertThat(\u0026quot;id\u0026quot;, 'is'(1L)) - проверка при компиляции\nЧитаемость assert \u0026ldquo;equals 3 x\u0026rdquo; assert \u0026ldquo;x is 3\u0026rdquo; - естественный порядок\nКомбинирование условий either(s).or(not(t)) each(s) И т.п. особенно с кастомными матчерами.\nСообщения об ошибках assertTrue(response.contains(\u0026#34;color\u0026#34;) || response.contains(\u0026#34;colour\u0026#34;)) // java.lang.AssertionError // at org.junit.Assert.fail(Assert.java) // at org.junit.Assert.assertTrue(...) // и т.п., никаких подробностей assertThat(response, anyOf(containsString(\u0026#34;color\u0026#34;),containsString(\u0026#34;colour\u0026#34;))) // java.lang.AssertionError: // Expected: (a string containing \u0026#34;color\u0026#34; or a string containing \u0026#34;colour\u0026#34;) // but: was \u0026#34;...\u0026#34; // Expected :(a string containing \u0026#34;color\u0026#34; or a string containing \u0026#34;colour\u0026#34;) // Actual :\u0026#34;...\u0026#34; Matchers Создание Для создания рекомендуется использвать фабричные методы:\nimport org.hamcrest.Matchers.hasSize assertThat(collection, hasSize(1)) Мотивация: меньше завязываемся на детали реализации, внутренние классы библиотеки.\nВерификация Необходимо проверять корректность использования Mockito. Для этого можно использовать Mockito.validateMockitoUsage() либо MockitoJUnit. Мотивация: нестабильные тесты. Нарушение контракта Mockito не приводит сразу к падению, но может влиять на другие тесты. Из-за параллельного запуска падать будут в произвольных местах.\n"});index.add({'id':54,'href':'/avito-android/docs/test/workmanager/','title':"Work Manager Testing",'content':"Work Manager Testing This document describes how to test WorkManager\u0026rsquo;s Workers.\nHow to test WorkManager\u0026rsquo;s Workers? The best way to test your Workers is the way described in official documentation. In short, you can test your Workers directly without initializing WorkManager.\nWorkManager is disabled for tests Because using real WorkManager while testing involves a lot of problems as it starts to initialize just before AvitoTestApp (using ContentProvider mechanism). Sometimes it leads to a classic race condition: some Worker tries to get its dependencies to build its own Dagger graph but Application isn\u0026rsquo;t ready so test runner ends up with a crash.\n"});index.add({'id':55,'href':'/avito-android/docs/assemble/benchmarks/','title':"Бенчмарки сборки",'content':"Бенчмарки сборки Для бенчмарков используем Gradle profiler, где можно описать воспрозводимый сценарий:\n Редактировать java/kotlin файлы, android ресурсы Переключаться между коммитами Проверить на разных версиях Gradle Почистить кеш, сборку Учесть прогрев перед измерениями  How to start  Установи вручную или скриптом: benchmarks/profiler.py --install Опиши свой сценарий. Возьми за основу один из готовых из ci/profiler/benchmarks.scenarios и посмотри какие операции необходимы.  Меняем код и ресурсы в модуле serp-core и собираем avito:\nserp_avito_assemble { tasks = [\u0026#34;:avito:assembleDebug\u0026#34;] apply-abi-change-to = \u0026#34;avito-libs/serp-core/src/main/java/com/avito/android/serp/SerpResult.kt\u0026#34; apply-android-resource-change-to = \u0026#34;avito-libs/serp-core/src/main/res/values/strings.xml\u0026#34; } Сохраняем сценарий в файл.\n Запусти профайлер:  gradle-profiler --benchmark \\  --project-dir . \\  --warmups 2 \\  --iterations 5 \\  --gradle-user-home ~/.gradle-profiler \\  --output-dir benchmarks/output \\  --scenario-file scenarios \\  serp_avito_assemble Все параметры запуска\nЧто измеряем в CI? Измеряем сценарии из ci/profiler/benchmarks.scenarios.\nЗапускаем в develop в конфигурации Profiler build (internal). Собираем только пару раз в день, потому что на каждый коммит не хватает железа.\nDashboard (internal) с этими сценариями.\n"});index.add({'id':56,'href':'/avito-android/docs/test/run/','title':"Введение",'content':"Запуск тестов IDE Обрати внимание на кастомные конфигурации\nRobolectric Просто запускаем стрелками Run напротив имени тестового класса или метода.\nВажно чтобы в настройках запуск был делегирован Gradle:\nPreferences \u0026gt; Build, Execution, Deployment \u0026gt; Build Tools \u0026gt; Gradle\nAS 3.6\u0026#43;  Build and run using: Gradle Run tests using: Gradle  AS 3.5   Delegate IDE build/run actions to Gradle Run tests using: Gradle Test Runner    Instrumentation Known issues  Не работает запуск конкретного метода в тесте, только всего класса (#127662898)  CI Кастомный запуск\n"});index.add({'id':57,'href':'/avito-android/docs/performance/analytics/','title':"Реалтайм-аналитика",'content':"Замеры перформанса экрана (internal) Что умеем замерять Пользовательские метрики  время от тача до начала инициализации экрана (предынициализация) время от тача до окончания отрисовки каждого из потоков данных экрана  Этапы работы экрана  время инициализации экрана (ScreenInitTracker) время DI экрана (ScreenDiInjectTracker) время загрузки данных по сети и с диска (наследники ContentLoadingTracker) время обработки данных, например конвертации сетевых моделей в презентационные (ViewDataPreparingTracker) - не всегда используется, потому что не везде есть время отрисовки (с момента посылки команды на отрисовку до того как соответсвующий Runnable отработал на main thread) длительность инициализации и DI компонентов (сабмодулей)  Отправляем метрики в statsd для realtime-аналитики и clickstream для AB-тестирования и детального анализа.\nПользовательские метрики отражают ожидания пользователя: тапнул по экрану - получил, что хотел.\nЧто нужно знать перед написанием кода  определить тип экрана (с предзагрузкой данных, самостоятельный, субкомпонент) создать абстракцию трекера экрана в соответствии с флоу экрана Типы флоу экранов добавить замеры в код синхронизировать имя вашего экрана (screenName) и замеряемые типы контента с таблицей (согласовать имена с iOS-платформой) проверить на дашборде, что ваши замеры действильно отправляются  Типы замеряемых экранов Самостоятельный экран  Activity без фрагментов Activity с Fragment, если он один на экране Конфигурация в которой есть Activity и несколько фрагментов одновременно на экране (В этом случае фрагменты выступают субкомпонентами)  Cубкомпонент  Fragment, который является одним из нескольких отображаемых фрагментов самостоятельного экрана (публичный профиль, главная, etc) Fragment, который является одним из шагов какого-нибудь флоу (подачи, выставления рейтинга продавцу, etc)  Если вы хотите все шаги какого-нибудь флоу затрекать как самостоятельные экраны, это также валидно. Рассматривать фрагмент как самостоятельный экран, так как и как субкомпонент в этом случае - вопрос предпочтений. Фрагмент, покрытый аналитикой, может и должен уметь выступать как самостоятельным экраном, так и субкомпонентом (элементом экрана).\nЭкран с предзагрузкой данных Когда экран осуществляет сетевые запросы и подготовку данных для отображения на следующем экране. Например, при выставлении рейтинга продавцу, сначала нажимаем на рейтинг, открывается фейковый экран с лоадером. Этот экран запрашивает данные для отображения следующего экрана, который будет известен по итогам запроса. Если авторизация есть - переходим на флоу выставления рейтинга, если нет - на авторизацию. С точки зрения пользователя: нажал на рейтинг, появился лоадер, появился экран выбора объявления, по которому будет выставляться рейтинг. Разумно считать, что этап предварительной подготовки для экрана с выбором объявления является частью флоу рейтинга.\nТипы трекеров  ScreenDiInjectTracker - трекает время инициализации DI и время предынициализации (от тача до начала DI) Время предынициализации трекается автоматически. ScreenInitTracker - время инициализации (создание и подключение презентеров, роутеров, вью) LocalContentLoadingTrackerImpl - загрузка одного из потоков данных из локального хранилища, скажем из префов ServerContentLoadingTrackerImpl - загрузка одного из потоков данных с сервера ViewDataPreparingTracker - подготовка данных для экрана (конвертация сетевых моделей в презентационные, например) ContentDrawingTracker - отрисовка данных. Через handler.post учитываает время, которое текущее изменение простояло в очереди на мейн треде UnknownScreenTracker - трекер для экрана с предзагрузкой данных  Понятия:\n screenName - имя экрана, которое обычно передается на этапе создания DI contentType - название потока данных. page - номер страницы. Обычно используется для экранов с бесконечными списками. Отправляется первые пять страниц (page-001..page-005), остальные отправляются как page-etc. Можно опустить. failure - либо failure либо success. Можно использовать свою константу для фейла. SCREEN - константа, которая используется для того, чтобы ScreenInitTracker и ScreenDiInjectTracker работали по умолчанию в режиме для самостоятельного экрана. NO_TIME - константа, которая используется в аргументах фукнций трекинга некоторых трекеров, когда мы хотим отправить данные в statsd, которые получили с прошлого экрана UnknownScreenTracker SUCCESS - дефолтная константа, которая используется в трекерах, которая обозначает, что в текущем потоке данных все операции прошли успешно. Успешно получили данные с сети, например, потом успешно их отрисовали.  В случае ScreenDiInjectTracker и ScreenInitTracker contentType используется для отличения субкомпонента от компонента. Например для экрана-субкомпонета выбора объявления, по которому будет выставляться рейтинг продавцу это будет select-advert. В случае ContentLoadingTracker-ов, ViewDataPreparingTracker, ContentDrawingTracker используется для обозначения потока данных. Например на главной странице это объявления adverts и шорткаты shortcuts.\nПользовательские метрики отправляются только первый раз при трекинге. Этапы работы экрана отправляются каждый раз при вызове соответствующего метода трекинга.\nПримеры вызовов методов трекеров:\ninterface ContentDrawingTracker : Tracker { fun trackContentDrawingTracker(page: Int? = null, failure: Boolean) } //затрекали успешную отрисовку (например, список объявлений) tracker.trackContentDrawingTracker(failure = false) //затрекали неуспешную отрисовку (например, заглушку с предложением повторить запрос) tracker.trackContentDrawingTracker(failure = true) interface ContentLoadingTracker : Tracker { fun trackContentLoading(page: Int? = null, failure: String, durationMs: Long = NO_TIME) } //затрекали успешную отрисовку 1 страницы (например, списка объявлений) tracker.trackContentLoading(page = 1, failure = SUCCESS) //затрекали неуспешную отрисовку 1 страницы (например, заглушку с предложением повторить запрос) tracker.trackContentLoading(page = 1, failure = FAILURE) Типы флоу экранов Флоу экранов бывают двух типов: стандартный и с предзагрузкой данных.\nСтандартный флоу экранов  Пользователь нажимает на кнопку на экране А Создается экран Б (здесь трекаем инициализацию и DI) Экран Б грузит данные (трекаем загрузку потока данных) Экран Б готовит презентационные данные (трекаем подготовку потока данных) Экран Б отрисовывает презентационные данные (трекаем отрисовку потока данных)  Флоу экранов с предзагрузкой Этот флоу отличаются от стандартных тем, что данные для отображения экран грузит не сам: данные для экрана грузит какой-либо предшествующий экран.\nЭкран Б из примеров - это экран с предзагрузкой [с экрана А].\nВариант 1\n Пользователь нажимает на кнопку на экране А Экран А грузит данные (Создаем UnknownScreenTracker и трекаем время загрузки данных) Создается экран Б (здесь восстанавливаем данные с экрана A через ScreenTransfer) Экран Б готовит презентационные данные Экран Б отрисовывает презентационные данные  Пример: пользователь нажимает кнопку \u0026ldquo;разместить объявление\u0026rdquo;. В зависимости от разных условий, пользователя могут отправить на экран размещенного объявления, на экран оплаты размещений или на экран применения дополнительных услуг.\nВариант 2\n Пользователь нажимает на кнопку на экране А Экран А переходит на экран с крутилкой, где это происходит Создаем UnknownScreenTracker и трекаем время инициализации, DI и загрузки данных Создается экран Б (здесь восстанавливаем данные с экрана A через ScreenTransfer) Экран Б готовит презентационные данные Экран Б отрисовывает презентационные данные  Преимущественно такая логика представлена в iOS-платформе.\nПример с главной страницы  graph TD A(Тап по шорткату. Запоминаем дату тача) --|ждем создания экрана| B(ОС создала экран Serp) B --|пошел метод onCreate. Начинаем трекать DI | C(Dependency Injection) C --|Здесь же начинаем трекать Init| D(Init. Закончили трекать когда подключились к презентеру) D -- E(load shortcuts) E -- G(prepare shortcuts) G -- K(draw shortcuts) D -- F(load serp) F -- H(prepare serp - переводим сетевые модели в презентационные) H -- L(draw serp) Как замерять перформанс самостоятельного экрана или субкомпонента В dagger dependency понадобится:\ninterface SelectAdvertDependencies : ComponentDependencies { ... fun screenTrackerFactory(): ScreenTrackerFactory fun timerFactory(): TimerFactory } Создаем dagger-модуль, который подключаем к компоненту экрана:\n@Module(includes = [Declarations::class]) object SelectAdvertAnalyticsModule { @Provides @PerFragment @JvmStatic fun providesScreenInitTracker( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, @ScreenAnalytics isSubComponent: Boolean, factory: TimerFactory ): ScreenInitTracker { return if (isSubComponent) { screenTrackerFactory.createInitTracker(screenName, factory, CONTENT_TYPE_SELECT_ADVERT) } else { screenTrackerFactory.createInitTracker(screenName, factory) } } @Provides @PerFragment @JvmStatic internal fun providesScreenDiInjectTracker( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, @ScreenAnalytics isSubComponent: Boolean, factory: TimerFactory ): ScreenDiInjectTracker { return if (isSubComponent) { screenTrackerFactory.createDiInjectTracker(screenName, factory, CONTENT_TYPE_SELECT_ADVERT) } else { screenTrackerFactory.createDiInjectTracker(screenName, factory) } } @Provides @PerFragment @JvmStatic fun providesScreenFlowTrackerProvider( screenTrackerFactory: ScreenTrackerFactory, @ScreenAnalytics screenName: String, factory: TimerFactory ): ScreenFlowTrackerProvider { return screenTrackerFactory.createScreenFlowTrackerProvider( screenName, factory ) } @Module internal interface Declarations { @Binds @PerFragment fun bindSelectAdvertTracker(tracker: SelectAdvertTrackerImpl): SelectAdvertTracker } }  isSubComponent: Boolean - если экран может использоваться как отдельный экран и как субкомпонент, этот флаг подскажет, как правильно настроить трекеры для отправки данных screenName - имя самостоятельного экрана, или родительского в случае субкомпонента. Требует согласования с iOS табличка CONTENT_TYPE_SELECT_ADVERT - строковая константа, которая помогает отличить данные текущего субкомпонента в графане от данных родительского экрана. Если константу не передавать как аргумент функции, то трекеры будут работать как для самостоятельного экрана с именем screenName если ваш экран не будет выступать в качестве субкомпонента, то isSubComponent можно не использовать.  Субкомпоненты удобны, когда вам нужно информацию со всех шагов видеть в одном окне в графане.\nОтличия самостоятельных экранов от субкомпонентов:\n У субкомпонента есть родитель - самостоятельный экран, который передает субкомпоненту собственный screen name. Все запросы на загрузку, подготовку и отрисовку буду относиться к screen name, который передал родитель субкомпонент имеет строковую константу content-type, которая прибавляется при отправке метрик инициализации и DI в statsd, чтобы отличать их от основного экрана У субкомпонентов трекается только абсолютное время DI и инициализации  Создаем абстракцию трекера:\nclass HomeTrackerImpl @Inject constructor( private val flowTrackerProvider: ScreenFlowTrackerProvider private val diInjectTracker: ScreenDiInjectTracker private val initTracker: ScreenInitTracker factory: TimerFactory ) : HomeTracker { private var locationFromSaveLoadTracker: ContentLoadingTracker? = null private var locationLoadTracker: ContentLoadingTracker? = null private var advertsLoadTracker: ContentLoadingTracker? = null private var advertsPrepareTracker: ViewDataPreparingTracker? = null private var advertsDrawingTracker: ContentDrawingTracker? = null private var shortcutsLoadTracker: ContentLoadingTracker? = null private var shortcutsPrepareTracker: ViewDataPreparingTracker? = null private var shortcutsDrawingTracker: ContentDrawingTracker? = null override fun trackDiInject(durationMs: Long) { diInjectTracker.track(durationMs) } override fun startInit() { initTracker.start() } override fun trackInit() { initTracker.trackInit() } override fun startLoadingLocation() { locationFromSaveLoadTracker = flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_LOAD_LOCATION_FROM_SAVE).apply { start() } } override fun trackLocationLoadedFromSave(locationIdForLoad: String?) { locationFromSaveLoadTracker?.trackContentLoading(null, SUCCESS) locationFromSaveLoadTracker = null locationLoadTracker = if (locationIdForLoad != null) { flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_LOAD_LOCATION) } else { flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_LOAD_LOCATION) }.apply { start() } } override fun trackLocationLoaded() { locationLoadTracker?.trackContentLoading(null, SUCCESS) locationLoadTracker = null } override fun trackLocationLoadError() { locationLoadTracker?.trackContentLoading(null, FAILURE) locationLoadTracker = null locationFromSaveLoadTracker?.trackContentLoading(null, FAILURE) locationFromSaveLoadTracker = null } override fun startLoadingAdverts() { advertsLoadTracker = flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_TYPE_ADVERT_ITEMS) .apply { start() } } override fun trackAdvertsLoaded(page: Int) { trackAdvertsLoaded(page, SUCCESS) } override fun trackAdvertsPrepare(page: Int) { trackAdvertsPrepare(page, false) } override fun startAdvertsDraw() { startAdvertsDrawingTracker() } override fun trackAdvertsDraw(page: Int) { trackAdvertsDraw(page, false) } override fun trackAdvertsLoadError(page: Int) { trackAdvertsLoaded(page, FAILURE) } override fun trackAdvertsErrorPrepare(page: Int) { trackAdvertsPrepare(page, true) } override fun trackAdvertsErrorDraw(page: Int) { trackAdvertsDraw(page, true) } private fun trackAdvertsLoaded(page: Int, result: String) { advertsLoadTracker?.trackContentLoading(page, result) advertsLoadTracker = null advertsPrepareTracker = flowTrackerProvider.getViewPreparing(CONTENT_TYPE_ADVERT_ITEMS).apply { start() } } private fun trackAdvertsPrepare(page: Int, failure: Boolean) { advertsPrepareTracker?.trackViewDataPreparing(page, failure) advertsPrepareTracker = null } private fun startAdvertsDrawingTracker() { advertsDrawingTracker = flowTrackerProvider.getContentDrawing(CONTENT_TYPE_ADVERT_ITEMS).apply { start() } } private fun trackAdvertsDraw(page: Int, failure: Boolean) { advertsDrawingTracker?.trackContentDrawingTracker(page, failure) advertsDrawingTracker = null } override fun startLoadingShortcuts(local: Boolean) { shortcutsLoadTracker = if (local) { flowTrackerProvider.getContentLoadingFromLocalStorage(CONTENT_TYPE_SHORTCUTS) } else { flowTrackerProvider.getContentLoadingFromRemoteStorage(CONTENT_TYPE_SHORTCUTS) }.apply { start() } } override fun trackShortcutsLoaded() { shortcutsLoadTracker?.trackContentLoading(null, SUCCESS) shortcutsLoadTracker = null } override fun startShortcutsPrepare() { shortcutsPrepareTracker = flowTrackerProvider.getViewPreparing(CONTENT_TYPE_SHORTCUTS).apply { start() } } override fun trackShortcutsPrepare() { shortcutsPrepareTracker?.trackViewDataPreparing(null, false) shortcutsPrepareTracker = null shortcutsDrawingTracker = flowTrackerProvider.getContentDrawing(CONTENT_TYPE_SHORTCUTS).apply { start() } } override fun trackShortcutsDraw() { shortcutsDrawingTracker?.trackContentDrawingTracker(null, false) shortcutsDrawingTracker = null } override fun stopShortcutsLoad() { shortcutsPrepareTracker = null } override fun trackShortcutsLoadError() { shortcutsLoadTracker?.trackContentLoading(null, FAILURE) shortcutsLoadTracker = null } override fun startReloadSession() { stopAllSessions() } override fun startLoadMoreSession() { stopAllSessions() } override fun stopLoadAdvertSession() { stopAllSessions() } Как выглядит трекер с предзагрузкой interface UnknownScreenTracker { fun trackInit(durationMs: Long) fun trackDiInject(durationMs: Long) fun startLoading() fun trackLoading() fun toScreenTransfer(): ScreenTransfer } Вариант 1. Необходимо затрекать только loading, потому что экран в целом отдельный и только запрос относится к целевому экрану.\nВариант 2. Необходимо затрекать init, di, loading, потому что экран целиком занимается тем, что выясняет, какой экран будет следующим.\nМетод toScreenTransfer отдает нам объект, хранящий все необходимые данные для передачи целевому экрану:\nclass ScreenTransfer( val initTime: Long, val loadingTime: Long, val diTime: Long ): Parcelable Этот объект необходимо положить в интент для целевого экрана с помощью BaseActivity.saturateIntentWithTrackingInfo\noverride fun followDeepLink(deepLink: DeepLink) { deepLinkIntentFactory.getIntent(deepLink) ?.let { startActivity(saturateIntentWithTrackingInfo(it, tracker.toScreenTransfer())) } } В целевом экране необходимо затрекать эти данные в onCreate:\nif (savedInstanceState == null) { val screenTransfer = rescueScreenTransfer() screenTransfer?.let { tracker.recover(it) } } Код трекера\nclass RatingPublishTrackerImpl @Inject constructor( ... private val recovery: ScreenTransferRecovery ) : RatingPublishTracker { override fun recover(transfer: ScreenTransfer) { recovery.recover(transfer, RATING_PUBLISH_NAME, CONTENT_TYPE_PRELOAD) } CONTENT_TYPE_PRELOAD - константа, которая позволяет правильно затрекать поток данных который был получен на предыдущем экране.\nRATING_PUBLISH_NAME - имя текущего экрана\nВ даггер модуль добавить:\n@Scope: PerActivity, PerFragment @Binds fun bindScreenTransferRecovery(recovery: ScreenTransferRecovery.Impl): ScreenTransferRecovery Как во время разработки проверить, что замеры отправляются Можно смотреть лог, в нем будут подобные строчки:\nTIME:android-debug.355.os.29.screen-performance.absolute.SearchResults.-.content-loading-server.advertisements.page-001.Wi-Fi.-.success:992\n android-debug - дебажная версия приложения, в релизной - android 355 - version code 29 - версия ОС SearchResults - screenName, имя экрана content-loading-server - загрузка данных с сервера advertisements - contentType, поток данных - объявления success - запрос закончился успешно 992 - количество миллиисекунд, которые длился запрос  Чтобы посмотреть отсылаемые в графану значения, нужно\n зайти на дашборд В Screen name выбрать имя вашего экрана В Release/debug выбрать android-debug для debug-сборки, и android - для релизной Должны появиться значения на дашбордах  Данные в дашборде отображаются с 30-секундной задержкой через сервис агрегации метрик statsd.\nПример в графане Пример с экрана RatingPublish\nВ панели Steps можно увидеть:\n preinit - время от тача по кнопке оставить рейтинг до начала DI экрана с флоу проставления рейтинга. Этот этап включает промежуточный шаг, когда пользователь видел лоадер preload init - этап инициализации экрана RatingPublish di-inject - этап DI экрана RatingPublish load preload - Промежуточный этап, когда пользователь видел лоадер preload. Затрекали с помощью UnknownScreenTracker draw preload - отрисовка данных полученных с прошлого экрана load adverts-list - этап загрузки с сервера списка объявлений на субкомпоненте-фрагменте select-advert (выбор объявления, по которому будет проставляться рейтинг, первый шаг на флоу проставления рейтинга) load next-step - этап загрузки с сервера следующего этапа экрана RatingPublish draw next-step, draw adverts-list - время отрисовки. Не стал отдельно трекать подготовку, ее здесь нет. Если бы залогировал, был бы еще этап подготовки: parse next-step, parse adverts-list component init select-advert - этап инициализации субкомпонента select-advert component di preload, component init preload - затрекали как субкомпонент время инициализации и DI с прошлого экрана component di select-advert - этап DI субкомпонента select-advert  "});index.add({'id':58,'href':'/avito-android/docs/ci/containers/','title':"Сборки в контейнерах",'content':"Сборки в контейнерах Avito Docker documentation (internal)\nВсе образы расположены в ci/docker.\nAndroid SDK Базовый образ c build tools. (будет сделан в MBS-7071)\nAndroid builder Образ который умеет собирать приложение в CI.\nHow to update?  Собери образ локально для проверки изменений:  cd ci/docker ./publish \u0026lt;папка с dockerfile\u0026gt;` В output будет новый tag образа.\n  Обнови тег образа в _main.sh в переменной IMAGE_ANDROID_BUILDER\n  Убедись что образ отрабатывает корректно при локальном использовании.\nПрогони хотя-бы ci/local_check.sh.\n  Собери образ на ветке в teamcity конфигурации Build android-builder (internal)\nВ этом проекте зашита авторизация для доступа к registry.\n  Обнови тег в _main.sh\n  Запушь изменение в ветку.\n  Docker in docker Утилитарный образ с докером внутри.\\ Используем внутри скриптов для создания и публикации других образов, прежде всего эмулятора.\nHow to update itself? Образ собирает сам себя с помощью предыдущей версии образа (bootstrapping):\n./publish.sh docker-in-docker-image\npublish.sh - использует текущую версию образа\ndocker-in-docker-image - содержит изменения\nЕсли меняем контракт с окружением, то вносим правки поэтапно, чтобы прошлая версия образа могла собрать новую.\nBuild docker-in-docker (internal)\nAndroid emulator Эмуляторы имеют кастомные настройки, оптимизированы для стабильности и производительности.\n Небольшое разрешение экрана: 320x480, 4 inch Отключены многие фичи  Как запустить эмулятор? OSX/Windows  CI эмулятор невозможно запустить из-за ограничений виртуализации haxm #51. Поэтому воспроизводим идентичную конфигурацию.\n Создай эмулятор в Android Studio: WVGA (Nexus One) с размером экрана 3.4\u0026rsquo;\u0026rsquo; и разрешением 480x800. Запусти эмулятор Настрой параметры:  adb root adb shell \u0026#34;settings put global window_animation_scale 0.0\u0026#34; adb shell \u0026#34;settings put global transition_animation_scale 0.0\u0026#34; adb shell \u0026#34;settings put global animator_duration_scale 0.0\u0026#34; adb shell \u0026#34;settings put secure spell_checker_enabled 0\u0026#34; adb shell \u0026#34;settings put secure show_ime_with_hard_keyboard 1\u0026#34; adb shell \u0026#34;settings put system screen_off_timeout 1800000\u0026#34; adb shell \u0026#34;settings put secure long_press_timeout 1500\u0026#34;  Перезагрузи эмулятор  См. все настройки в android-emulator/hardware и android-emulator/prepare_snapshot.sh\nЗадача на автоматизацию (internal)\n Linux  Проще и надежнее использовать оригинальные CI эмуляторы.\nТребования:\n  Docker\n  KVM\n  Найди актуальную версию образа в Emulator.kt.\n  Разреши подключение к Xorg серверу с любого хоста (изнутри контейнера в нашем случае):\n  xhost +  Запусти эмулятор:  docker run -d \\  -p 5555:5555 \\  -p 5554:5554 \\  -e \u0026#34;SNAPSHOT_DISABLED\u0026#34;=\u0026#34;true\u0026#34; -e \u0026#34;WINDOW\u0026#34;=\u0026#34;true\u0026#34; --volume=\u0026#34;/tmp/.X11-unix:/tmp/.X11-unix:rw\u0026#34; \\  --privileged \\  \u0026lt;registry\u0026gt;/android/emulator-27:\u0026lt;TAG\u0026gt; Или в headless режиме:\ndocker run -d \\  -p 5555:5555 \\  -p 5554:5554 \\  --privileged \\  \u0026lt;registry\u0026gt;/android/emulator-27:\u0026lt;TAG\u0026gt;  Подключись к эмулятору в adb  adb connect localhost:5555    Как обновить образ? Для эмулятора нужна более сложная подготовка, поэтому используем отдельные скрипты и образы.\nCI   Собери образ на ветке в teamcity конфигурации Build android-emulator (internal).\nТеги новых образов будут в файле в артефактах сборки. Обнови теги в Devices.kt Запушь изменение в ветку.   Local  Требования:\n Linux, docker KVM K8S права на push образов в registry-mobile-apps (env переменные DOCKER_LOGIN, DOCKER_PASSWORD)   Запусти скрипт:  cd ci/docker ./publish_emulator android-emulator Соберет образ, протестирует и запушит в docker registry.\n Найти новые теги образов. См. stdout скрипта или файл android-emulator/images.txt Обнови теги образов в _main.sh    Как проверить регрессию?  Прогони instrumentation dynamic чтобы выявить возможную утечку памяти.\nДля этого запусти компонентный тест с большим числом повторов. Прогони fullCheck\nСравни количество тестов по всем статусам, не стало ли больше упавших или потерянных.  Как проверить сколько ресурсов тратит эмулятор? Локально используем cAdvisor\nsudo docker run \\  --volume=/:/rootfs:ro \\  --volume=/var/run:/var/run:ro \\  --volume=/sys:/sys:ro \\  --volume=/var/lib/docker/:/var/lib/docker:ro \\  --volume=/dev/disk/:/dev/disk:ro \\  --publish=8080:8080 \\  --detach=true \\  --name=cadvisor \\  google/cadvisor:latest В CI смотрим в метрики куба.\nBest practices Reproducible image Хотим получать одинаковый образ на любой машине, в любом окружении. Это упрощает отладку проблем и делает сборку более надежной.\nreproducible-builds.org\nИсточники нестабильности:\n Не указана явно версия зависимости. Копируем в образ файлы, сгенерированные вне докера.\nГлядя на такие файлы трудно сказать в каком окружении они созданы, какое содержание ожидаемое.  "});index.add({'id':59,'href':'/avito-android/docs/test/screenshottesting/','title':"Скриншотные тесты",'content':"Скриншотные тесты Цель Скриншотные тесты позволяют вовремя отследить изменения цветов / стилей и предотвратить нежелательные изменения в UI\nЧто именно покрывают скриншотные тесты? Сейчас скриншотные тесты распространяются только на компоненты из дизайн системы\nОграничения В данный момент скриншотные тесты заливаются в git без использования git-lfs. Разумеется, если скриншотов в истории git будет слишком много, то вес репозитория будет слишком большой и работа с ним в целом замедлится. По рассчетам еще не скоро это станет проблемой, договорились что стоит поднимать вопрос после планки в 50 mb\nКак узнать сколько места скриншоты занимают сейчас? Следует запустить скрипт, который покажет текущий размер директории, учитывая удаленные и замененные файлы\nПримечание: сейчас в папке со скриншотами так же есть в истории скриншоты старых тестов, занимающие 16 mb\nsh screenshot_test_size.sh Как узнать какие именно файлы были посчитаны? Запустить скрипт:\nsh file-sizes.sh Я поменял цвета/стили и теперь скриншотные тесты не проходят на CI, что делать?   Убедиться что поменялось только то, что нужно.\n  Обязательно добавить @aodanilov и @poignatov в PR\n  (Опционально) удалить папку /design-app/src/androidTest/assets/screenshots\n  Выставить нужный эмулятор локально\nПримечание: просто создать эмулятор не выйдет, так как эмулятор на CI обладает кастомными характеристиками, поэтому нужно взять характеристики для 27 API из /ci/docker/android-emulator/hardware и добавить их в config.ini своего эмулятора, который лежит по адресу ~/.android/avd/\u0026lt;название эмулятора\u0026gt;.avd самое главное - это сделать одинаковыми параметры\nhw.lcd.width\nhw.lcd.height\nhw.lcd.density\n  Проверить, что все остальные эмуляторы выключены\n  Перегенерировать скриншоты командой\n  sh record_screenshots.sh  Скриншоты добавятся в папку /design-app/src/androidTest/assets/screenshots/ Можно коммитить их и пушить  Где хранятся скриншоты? Скриншоты хранятся в папке /design-app/src/androidTest/assets/screenshots\nВнутри этой папки скриншоты разделяются по папкам далее используя контракт имени API_{API_VERSION}_{WIDTH}x{HEIGHT}_{DENSITY}, на данный момент используется только один эмулятор, соответственно название папки выглядит так: API_27_320x480_120\n"});index.add({'id':60,'href':'/avito-android/docs/externallibrarychangeprocess/','title':"Соглашения по работе с внешними библиотеками",'content':"Соглашения по работе с внешними библиотеками Описание устарело.\nНужно пересмотреть и перенести на страницу про работу с зависимостями.    Не нужно использовать без необходимости внешние библиотеки - ради абзаца кода нет смысла утяжелять проект\n  Не стоит использовать библиотеки сомнительного качества:\n С низким рейтингом Плохо покрытые тестами Давно не обновляемые Код в которых заведомо низкого качества и т.п.    Наличие или отсутствие каких-либо из этих свойств не является определяющим при выборе библиотеки. Необходимо руководствоваться требованиями разумности и здравого смысла.\n Перед внедрением библиотеки обсуди с коллегами целесообразность. Обрати внимание на качество библиотеки и ее аналогов: завязка на некачественную библиотеку может стать дорогой в поддержке.  Best practices Хотим использовать актуальные версии зависимостей.\nВыделили ряд соглашений, чтобы не сломать релиз и упростить обновления:\n Не обновлять много зависимостей в одном ПР. Так повышается скорость локализации некорректно работающей библиотеки в случае обнаружения проблем с приложением. Исключения - семейства сильно связанных библиотек: RxJava и т.п. Обновлять версию библиотеки желательно в начале-середине цикла разработки, а не перед стабилизацией/подготовке к регрессу Не использовать нестабильные версии библиотек (snapshot и тп) Обновлять легкие библиотеки или библиотеки, некорректная работа которых будет заметна сразу (dagger2) рекомендуется на версию, которая является набором багфиксов Не рекомендуется обновлять легкую библиотеку на релиз, в котором есть фичи - это источник потенциально нестабильного кода. Упрощая - библиотеки, версия которых заканчивается на 0 (1.2.0) не стоит интегрировать без определенной надобности - лучше подождать начала следующего цикла разработки Тяжелые библиотеки (Google Play Services, Support Library) нельзя обновлять перед регрессом/стабилизацией. Исключения возможны только в случае, если в версии библиотеки вносятся фиксы, которые решают проблемы текущей подготавливаемой версии. Но и в этом случае не рекомендуется ставить версию библиотеки, которая не является набором багфиксов. Такие библиотеки в конце цикла разработки могут версионироваться только по консенсусному согласию с коллегами о необходимости интеграции конкретной версии  "});})();